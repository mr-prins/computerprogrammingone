{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Computer Programming I! This is an introductory course in program engineering and applications. This course introduces students to the fundamentals of computer programming. Throughout the semester, students will learn to design, code, and test their own programs while applying mathematical concepts. They will also be exposed to problem-solving techniques while approaching coding challenges, with the goal to prepare them for a more advanced programming course in the future. To achieve this objective, we will use the Python programming language, one of the most vastly used coding languages out there. However, with the concepts learned in this course, the student will be able to learn any other languages on their own, if they so desire. Course Objectives Students will be familiar with IDEs. Students will understand program development methodology and best practices. Students will understand and implement key programming concepts. Students will understand and implement control structures. Students will be aware of career opportunities in the Computer Programming/Software Engineering industry. This Is What This Course Is Not This is not an advanced course in Python. In fact, this is very introductory. This is not perfect, and it is probably going to be in development for a long time. Students will NOT become hackers in this course. Students will NOT learn how to fix computers in this course. Students will NOT know how to create a web page for a company in this course. Students will NOT become expert programmers or geniuses in this course. For Parents This website was designed to offer you some insight about what your child is learning in class. It will also serve as some sort of calendar, so you know which assignments your child has to complete and when they have to complete it. I also want to make sure you understand that you can reach out to me whenever you want if you have any questions or concerns. I want to make sure your child has the best education possible, but you have to be involved for this to be more easily achievable. If we work together, we can ensure your child will have better chances to succeed in life. For Students Find a mistake or suggest a good improvement and I'll give you a gift card! Your child will probably need to study at home to complete this course successfully. Please encourage them to do so.","title":"About"},{"location":"#welcome-to-computer-programming-i","text":"This is an introductory course in program engineering and applications. This course introduces students to the fundamentals of computer programming. Throughout the semester, students will learn to design, code, and test their own programs while applying mathematical concepts. They will also be exposed to problem-solving techniques while approaching coding challenges, with the goal to prepare them for a more advanced programming course in the future. To achieve this objective, we will use the Python programming language, one of the most vastly used coding languages out there. However, with the concepts learned in this course, the student will be able to learn any other languages on their own, if they so desire.","title":"Welcome to Computer Programming I!"},{"location":"#course-objectives","text":"Students will be familiar with IDEs. Students will understand program development methodology and best practices. Students will understand and implement key programming concepts. Students will understand and implement control structures. Students will be aware of career opportunities in the Computer Programming/Software Engineering industry.","title":"Course Objectives"},{"location":"#this-is-what-this-course-is-not","text":"This is not an advanced course in Python. In fact, this is very introductory. This is not perfect, and it is probably going to be in development for a long time. Students will NOT become hackers in this course. Students will NOT learn how to fix computers in this course. Students will NOT know how to create a web page for a company in this course. Students will NOT become expert programmers or geniuses in this course.","title":"This Is What This Course Is Not"},{"location":"#for-parents","text":"This website was designed to offer you some insight about what your child is learning in class. It will also serve as some sort of calendar, so you know which assignments your child has to complete and when they have to complete it. I also want to make sure you understand that you can reach out to me whenever you want if you have any questions or concerns. I want to make sure your child has the best education possible, but you have to be involved for this to be more easily achievable. If we work together, we can ensure your child will have better chances to succeed in life.","title":"For Parents"},{"location":"#for-students","text":"Find a mistake or suggest a good improvement and I'll give you a gift card! Your child will probably need to study at home to complete this course successfully. Please encourage them to do so.","title":"For Students"},{"location":"links/","text":"Useful Links I will add links here that I find useful and good. Websites Python for Everybody Python for Beginners - Python Official Page Automate the Boring Stuff With Python Python Tips - Intermediate/Advanced Python tips Books Python Distilled - Amazon Link Videos Anthony Writes Code","title":"Useful Links"},{"location":"links/#useful-links","text":"I will add links here that I find useful and good.","title":"Useful Links"},{"location":"links/#websites","text":"Python for Everybody Python for Beginners - Python Official Page Automate the Boring Stuff With Python Python Tips - Intermediate/Advanced Python tips","title":"Websites"},{"location":"links/#books","text":"Python Distilled - Amazon Link","title":"Books"},{"location":"links/#videos","text":"Anthony Writes Code","title":"Videos"},{"location":"course/section_01/","text":"Git and Github What is Git? Git is a powerful tool used by software developers to manage and keep track of changes in their code. Think of it as a sophisticated \"undo\" button for your projects, allowing you to revert to previous versions of your code, track changes over time, and collaborate with others without losing your work. Here are some key features of Git: Version Control: Git keeps a history of all changes made to your code, so you can see what was changed, who changed it, and when. Branching and Merging: You can create branches to work on new features or bug fixes without affecting the main codebase. Once your work is complete, you can merge it back into the main branch. Collaboration: Multiple people can work on the same project simultaneously without overwriting each other's work. What is GitHub? GitHub is an online platform that hosts Git repositories, making it easier for you to manage your projects and collaborate with others. It's like a social network for programmers, where you can share your code, contribute to others' projects, and showcase your work. Here are some things you can do with GitHub: Repository Hosting: Store your projects in repositories, which are like folders for your code. Collaboration Tools: Use pull requests to review and discuss changes before merging them into your project. Project Management: Organize your work with issues, milestones, and project boards. Community Engagement: Follow other developers, contribute to open-source projects, and build your professional network. How Git and GitHub Work Together Initialize a Repository: Start by creating a new repository on your computer using Git. This will track changes to your project files. Make Changes: Write code, make changes, and commit them to your local repository. A commit is like a snapshot of your project at a particular point in time. Push to GitHub: Once you have a series of commits, you can push them to GitHub, making your changes available online. Collaborate: Others can clone your repository, make changes, and submit pull requests. You can review these changes and merge them into your project. Some Basic Git Commands Here are some essential Git commands you'll use frequently: git init : Initializes a new Git repository. git clone [url] : Copies an existing repository from GitHub to your local machine. git status : Shows the status of changes in your working directory. git add [file] : Stages a file, preparing it for a commit. git commit -m \"message\" : Commits the staged changes with a descriptive message. git push : Uploads your commits to GitHub. git pull : Fetches and integrates changes from GitHub to your local repository. Getting Started with GitHub Sign Up: Create a free account on GitHub. Create a Repository: Click the \"New\" button on your GitHub dashboard to create a new repository. Clone the Repository: Use git clone [url] to copy the repository to your computer. Start Coding: Make changes to your project files, commit them, and push them to GitHub. By using Git and GitHub, you'll learn valuable skills for managing your code and collaborating with others. As we progress through the course, you'll become more comfortable with these tools and see how they fit into the larger world of software development. Class Assignment For this class assignment, we will work with GitHub's built in tutorial, available in our GitHub Classroom. Here's the link to the first assignment: First Assignment - Git and GitHub fundamentals DEADLINE: August 23, at midnight!","title":"Git and GitHub"},{"location":"course/section_01/#git-and-github","text":"","title":"Git and Github"},{"location":"course/section_01/#what-is-git","text":"Git is a powerful tool used by software developers to manage and keep track of changes in their code. Think of it as a sophisticated \"undo\" button for your projects, allowing you to revert to previous versions of your code, track changes over time, and collaborate with others without losing your work. Here are some key features of Git: Version Control: Git keeps a history of all changes made to your code, so you can see what was changed, who changed it, and when. Branching and Merging: You can create branches to work on new features or bug fixes without affecting the main codebase. Once your work is complete, you can merge it back into the main branch. Collaboration: Multiple people can work on the same project simultaneously without overwriting each other's work.","title":"What is Git?"},{"location":"course/section_01/#what-is-github","text":"GitHub is an online platform that hosts Git repositories, making it easier for you to manage your projects and collaborate with others. It's like a social network for programmers, where you can share your code, contribute to others' projects, and showcase your work. Here are some things you can do with GitHub: Repository Hosting: Store your projects in repositories, which are like folders for your code. Collaboration Tools: Use pull requests to review and discuss changes before merging them into your project. Project Management: Organize your work with issues, milestones, and project boards. Community Engagement: Follow other developers, contribute to open-source projects, and build your professional network.","title":"What is GitHub?"},{"location":"course/section_01/#how-git-and-github-work-together","text":"Initialize a Repository: Start by creating a new repository on your computer using Git. This will track changes to your project files. Make Changes: Write code, make changes, and commit them to your local repository. A commit is like a snapshot of your project at a particular point in time. Push to GitHub: Once you have a series of commits, you can push them to GitHub, making your changes available online. Collaborate: Others can clone your repository, make changes, and submit pull requests. You can review these changes and merge them into your project.","title":"How Git and GitHub Work Together"},{"location":"course/section_01/#some-basic-git-commands","text":"Here are some essential Git commands you'll use frequently: git init : Initializes a new Git repository. git clone [url] : Copies an existing repository from GitHub to your local machine. git status : Shows the status of changes in your working directory. git add [file] : Stages a file, preparing it for a commit. git commit -m \"message\" : Commits the staged changes with a descriptive message. git push : Uploads your commits to GitHub. git pull : Fetches and integrates changes from GitHub to your local repository.","title":"Some Basic Git Commands"},{"location":"course/section_01/#getting-started-with-github","text":"Sign Up: Create a free account on GitHub. Create a Repository: Click the \"New\" button on your GitHub dashboard to create a new repository. Clone the Repository: Use git clone [url] to copy the repository to your computer. Start Coding: Make changes to your project files, commit them, and push them to GitHub. By using Git and GitHub, you'll learn valuable skills for managing your code and collaborating with others. As we progress through the course, you'll become more comfortable with these tools and see how they fit into the larger world of software development.","title":"Getting Started with GitHub"},{"location":"course/section_01/#class-assignment","text":"For this class assignment, we will work with GitHub's built in tutorial, available in our GitHub Classroom. Here's the link to the first assignment: First Assignment - Git and GitHub fundamentals DEADLINE: August 23, at midnight!","title":"Class Assignment"},{"location":"course/section_02/","text":"Basic Types in Python Why Do We Use Programming? Programming allows us to perform operations on data to solve problems, automate tasks, and create applications. Imagine you have a list of students' grades and you want to find the average. Doing this manually is time-consuming and prone to errors. With programming, you can write a few lines of code to calculate the average quickly and accurately. The Need for Types When programming, it's important to understand the kind of data we're working with. Different types of data require different operations. For example, you can add two numbers together, but adding a number and a word doesn't make sense. This is where types come in. Types help the computer understand what kind of data it is dealing with so it can perform the correct operations. Types in Python Python, like many programming languages, has several built-in types to handle different kinds of data. Let's explore the most common types: Integers ( int ) Integers are whole numbers, both positive and negative. They do not have any decimal points. 5 -42 1000 Floating-Point Numbers ( float ) Floating-point numbers are numbers with decimal points. They can represent very large or very small numbers. 3.14 -0.001 100.0 Strings ( str ) Strings are sequences of characters, like words or sentences. They are enclosed in either single quotes ( ' ) or double quotes ( \" ). \"Hello, world!\" 'Python is fun!' \"12345\" # This is a string, not an integer Booleans ( bool ) Booleans represent one of two values: True or False . They are used to perform logical operations and control the flow of a program. True False Lists ( list ) Lists are ordered collections of items. You can store different types of data in a list, and lists can be changed after they are created. [1, 2, 3, 4, 5] [\"apple\", \"banana\", \"cherry\"] [True, False, True] Tuples ( tuple ) Tuples are similar to lists, but they are immutable, meaning they cannot be changed after they are created. They are useful for storing related pieces of data that should not be altered. (1, 2, 3) (\"red\", \"green\", \"blue\") (True, False, False) Dictionaries ( dict ) Dictionaries are collections of key-value pairs. Each key in a dictionary is unique and is used to store and retrieve values. {\"name\": \"Alice\", \"age\": 25, \"city\": \"New York\"} {\"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1964} The Concept of Values In programming, a value is the actual data stored in a variable or constant. The type of a value determines what operations can be performed on it. For example, you can add, subtract, multiply, and divide integer and floating-point values, but you can't perform these operations on strings. Integer value: 42 Floating-point value: 3.14159 String value: \"Hello\" Boolean value: True Understanding types and values is fundamental to programming because it helps you write correct and efficient code. As you practice more, you'll become familiar with how to use different types to solve problems and create applications.","title":"Basic Types in Python"},{"location":"course/section_02/#basic-types-in-python","text":"","title":"Basic Types in Python"},{"location":"course/section_02/#why-do-we-use-programming","text":"Programming allows us to perform operations on data to solve problems, automate tasks, and create applications. Imagine you have a list of students' grades and you want to find the average. Doing this manually is time-consuming and prone to errors. With programming, you can write a few lines of code to calculate the average quickly and accurately.","title":"Why Do We Use Programming?"},{"location":"course/section_02/#the-need-for-types","text":"When programming, it's important to understand the kind of data we're working with. Different types of data require different operations. For example, you can add two numbers together, but adding a number and a word doesn't make sense. This is where types come in. Types help the computer understand what kind of data it is dealing with so it can perform the correct operations.","title":"The Need for Types"},{"location":"course/section_02/#types-in-python","text":"Python, like many programming languages, has several built-in types to handle different kinds of data. Let's explore the most common types:","title":"Types in Python"},{"location":"course/section_02/#integers-int","text":"Integers are whole numbers, both positive and negative. They do not have any decimal points. 5 -42 1000","title":"Integers (int)"},{"location":"course/section_02/#floating-point-numbers-float","text":"Floating-point numbers are numbers with decimal points. They can represent very large or very small numbers. 3.14 -0.001 100.0","title":"Floating-Point Numbers (float)"},{"location":"course/section_02/#strings-str","text":"Strings are sequences of characters, like words or sentences. They are enclosed in either single quotes ( ' ) or double quotes ( \" ). \"Hello, world!\" 'Python is fun!' \"12345\" # This is a string, not an integer","title":"Strings (str)"},{"location":"course/section_02/#booleans-bool","text":"Booleans represent one of two values: True or False . They are used to perform logical operations and control the flow of a program. True False","title":"Booleans (bool)"},{"location":"course/section_02/#lists-list","text":"Lists are ordered collections of items. You can store different types of data in a list, and lists can be changed after they are created. [1, 2, 3, 4, 5] [\"apple\", \"banana\", \"cherry\"] [True, False, True]","title":"Lists (list)"},{"location":"course/section_02/#tuples-tuple","text":"Tuples are similar to lists, but they are immutable, meaning they cannot be changed after they are created. They are useful for storing related pieces of data that should not be altered. (1, 2, 3) (\"red\", \"green\", \"blue\") (True, False, False)","title":"Tuples (tuple)"},{"location":"course/section_02/#dictionaries-dict","text":"Dictionaries are collections of key-value pairs. Each key in a dictionary is unique and is used to store and retrieve values. {\"name\": \"Alice\", \"age\": 25, \"city\": \"New York\"} {\"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1964}","title":"Dictionaries (dict)"},{"location":"course/section_02/#the-concept-of-values","text":"In programming, a value is the actual data stored in a variable or constant. The type of a value determines what operations can be performed on it. For example, you can add, subtract, multiply, and divide integer and floating-point values, but you can't perform these operations on strings. Integer value: 42 Floating-point value: 3.14159 String value: \"Hello\" Boolean value: True Understanding types and values is fundamental to programming because it helps you write correct and efficient code. As you practice more, you'll become familiar with how to use different types to solve problems and create applications.","title":"The Concept of Values"},{"location":"course/section_03/","text":"Code Structure Writing code is like writing a set of instructions for the computer to follow. How we organize these instructions is called code structure . Good code structure makes your programs easier to read, understand, and maintain. Here are some key elements of code structure: Indentation In Python, indentation (spaces at the beginning of a line) is used to define the structure of your code. The standard indentation in Python is four spaces . Code blocks (like the body of a loop or a function) are indented to show that they belong to a specific structure. if True: print(\"This is indented\") Comments Comments are notes you can add to your code to explain what it does. They are ignored by the computer and are meant to help humans understand the code. # This is a comment print(\"Hello, world!\") # This prints a message to the screen Code Blocks A code block is a group of statements that are executed together. In Python, code blocks are defined by their indentation. Examples of Code Blocks: If Statement if condition: # This is a code block print(\"Condition is true\") For Loop for i in range(5): # This is a code block print(i) Function Definition def greet(name): # This is a code block print(f\"Hello, {name}!\") Expressions An expression is a combination of values, variables, and operators that the computer evaluates to produce another value. Expressions can be as simple as a single value or as complex as a series of operations. 5 + 3 (This evaluates to 8 ) len(\"Hello\") (This evaluates to 5 ) x * y - z (This evaluates to the result of multiplying x and y and then subtracting z ) Expressions are used in assignments, function calls, and other operations to produce values that your program can work with. Symbols Symbols are named entities that hold values in Python. This is how we give names to values (objects): Symbols must begin with an underscore or letter. Symbols can contain any number of underscores, letters and numbers. this_is_a_symbol this_is_2 _AsIsThis 1butThisIsNot nor-is-this Symbols (names) don\u2019t have a type; values do. This is why Python is \u201cDynamic\u201d. PEP8 (PEP stands for Python Enhancement Proposal) is the document that dictates how we name things in Python. Here's a link to it. Variables A variable is a symbol that holds a value. Think of it as a container that stores data that can be used and manipulated in your program. Variables make your code more flexible and easier to understand. To create a variable, you simply give it a name and assign it a value using the equals sign ( = ). age = 16 name = \"John\" is_student = True Constants A constant is similar to a variable, but its value is meant to remain the same throughout the program. By convention, constants are written in all uppercase letters. PI = 3.14159 MAX_STUDENTS = 30 Constants are useful for values that do not change, such as mathematical constants or configuration settings. Summary Here's a small program that demonstrates code structure, code blocks, expressions, and symbols: # Define a constant PI = 3.14159 # Define a function to calculate the area of a circle def calculate_area(radius): # This is a code block inside the function area = PI * (radius ** 2) return area # Main part of the program radius = 5 print(f\"The area of a circle with radius {radius} is {calculate_area(radius)}\") In this example: We define a constant PI . We define a function calculate_area with a code block inside. We use an expression PI * (radius ** 2) to calculate the area. We create a variable radius and use it in a function call.","title":"Code Structure"},{"location":"course/section_03/#code-structure","text":"Writing code is like writing a set of instructions for the computer to follow. How we organize these instructions is called code structure . Good code structure makes your programs easier to read, understand, and maintain. Here are some key elements of code structure:","title":"Code Structure"},{"location":"course/section_03/#indentation","text":"In Python, indentation (spaces at the beginning of a line) is used to define the structure of your code. The standard indentation in Python is four spaces . Code blocks (like the body of a loop or a function) are indented to show that they belong to a specific structure. if True: print(\"This is indented\")","title":"Indentation"},{"location":"course/section_03/#comments","text":"Comments are notes you can add to your code to explain what it does. They are ignored by the computer and are meant to help humans understand the code. # This is a comment print(\"Hello, world!\") # This prints a message to the screen","title":"Comments"},{"location":"course/section_03/#code-blocks","text":"A code block is a group of statements that are executed together. In Python, code blocks are defined by their indentation. Examples of Code Blocks:","title":"Code Blocks"},{"location":"course/section_03/#if-statement","text":"if condition: # This is a code block print(\"Condition is true\")","title":"If Statement"},{"location":"course/section_03/#for-loop","text":"for i in range(5): # This is a code block print(i)","title":"For Loop"},{"location":"course/section_03/#function-definition","text":"def greet(name): # This is a code block print(f\"Hello, {name}!\")","title":"Function Definition"},{"location":"course/section_03/#expressions","text":"An expression is a combination of values, variables, and operators that the computer evaluates to produce another value. Expressions can be as simple as a single value or as complex as a series of operations. 5 + 3 (This evaluates to 8 ) len(\"Hello\") (This evaluates to 5 ) x * y - z (This evaluates to the result of multiplying x and y and then subtracting z ) Expressions are used in assignments, function calls, and other operations to produce values that your program can work with.","title":"Expressions"},{"location":"course/section_03/#symbols","text":"Symbols are named entities that hold values in Python. This is how we give names to values (objects): Symbols must begin with an underscore or letter. Symbols can contain any number of underscores, letters and numbers. this_is_a_symbol this_is_2 _AsIsThis 1butThisIsNot nor-is-this Symbols (names) don\u2019t have a type; values do. This is why Python is \u201cDynamic\u201d. PEP8 (PEP stands for Python Enhancement Proposal) is the document that dictates how we name things in Python. Here's a link to it.","title":"Symbols"},{"location":"course/section_03/#variables","text":"A variable is a symbol that holds a value. Think of it as a container that stores data that can be used and manipulated in your program. Variables make your code more flexible and easier to understand. To create a variable, you simply give it a name and assign it a value using the equals sign ( = ). age = 16 name = \"John\" is_student = True","title":"Variables"},{"location":"course/section_03/#constants","text":"A constant is similar to a variable, but its value is meant to remain the same throughout the program. By convention, constants are written in all uppercase letters. PI = 3.14159 MAX_STUDENTS = 30 Constants are useful for values that do not change, such as mathematical constants or configuration settings.","title":"Constants"},{"location":"course/section_03/#summary","text":"Here's a small program that demonstrates code structure, code blocks, expressions, and symbols: # Define a constant PI = 3.14159 # Define a function to calculate the area of a circle def calculate_area(radius): # This is a code block inside the function area = PI * (radius ** 2) return area # Main part of the program radius = 5 print(f\"The area of a circle with radius {radius} is {calculate_area(radius)}\") In this example: We define a constant PI . We define a function calculate_area with a code block inside. We use an expression PI * (radius ** 2) to calculate the area. We create a variable radius and use it in a function call.","title":"Summary"},{"location":"course/section_04/","text":"Expressions and Variables Expressions An expression in Python is a combination of values, variables, and operators that, when evaluated, produces a new value. Expressions are fundamental building blocks in programming and are used to perform calculations, manipulate data, and control the flow of a program. Types of Expressions Arithmetic Expressions These involve mathematical operations like addition, subtraction, multiplication, and division. 5 + 3 # Addition, evaluates to 8 10 - 2 # Subtraction, evaluates to 8 4 * 2 # Multiplication, evaluates to 8 16 / 2 # Division, evaluates to 8.0 String Expressions These involve operations on strings, such as concatenation. \"Hello, \" + \"world!\" # Concatenation, evaluates to \"Hello, world!\" Boolean Expressions These involve logical operations and comparisons, resulting in a Boolean value ( True or False ). 5 > 3 # Greater than, evaluates to True 10 == 2 * 5 # Equality, evaluates to True 4 != 2 + 2 # Inequality, evaluates to False Function Calls Expressions can also involve calling functions, which may return values. len(\"Hello\") # Function call, evaluates to 5 Evaluating Expressions When Python encounters an expression, it evaluates it to produce a value. This value can then be used in further calculations, assigned to variables, or passed to functions. result = 5 + 3 # The expression 5 + 3 evaluates to 8, which is assigned to the variable result print(result) # This prints 8 Variables A variable is a named storage location in memory that holds a value. Variables allow you to store data and refer to it later in your program. You can think of a variable as a container for data. Variables are essential because they allow you to: Store and reuse values. Make your code more readable and maintainable. Write flexible and dynamic programs. Declaring and Initializing Variables To declare a variable, you simply assign a value to it using the equals sign ( = ). This process is called initialization. age = 16 # The variable age is assigned the value 16 name = \"Alice\" # The variable name is assigned the value \"Alice\" is_student = True # The variable is_student is assigned the value True Using Variables Once you have declared a variable, you can use it in expressions, pass it to functions, and modify its value. # Using variables in expressions x = 10 y = 5 sum = x + y # sum is assigned the value 15 # Passing variables to functions def greet(person): print(f\"Hello, {person}!\") greet(name) # This prints \"Hello, Alice!\" # Modifying variables count = 0 count = count + 1 # count is now 1 count += 2 # count is now 3 Variable Naming Rules When naming variables in Python, follow these rules: Use letters (a-z, A-Z), digits (0-9), and underscores (_). Do not start a variable name with a digit. Variable names are case-sensitive ( age and Age are different variables). Choose meaningful names that describe the data they hold. Valid examples: student_name = \"John\" total_score = 95 is_enrolled = True Invalid examples: 2nd_place = \"Bob\" # Starts with a digit total-score = 95 # Uses a hyphen instead of an underscore class = \"Math\" # Uses a reserved keyword Good practice dictates that PEP8 rules for naming variables should be followed. Here's a link to it. Constants A constant is similar to a variable but is meant to remain unchanged throughout the program. By convention, constants are written in all uppercase letters. PI = 3.14159 MAX_STUDENTS = 30","title":"Expressions and Variables"},{"location":"course/section_04/#expressions-and-variables","text":"","title":"Expressions and Variables"},{"location":"course/section_04/#expressions","text":"An expression in Python is a combination of values, variables, and operators that, when evaluated, produces a new value. Expressions are fundamental building blocks in programming and are used to perform calculations, manipulate data, and control the flow of a program.","title":"Expressions"},{"location":"course/section_04/#types-of-expressions","text":"","title":"Types of Expressions"},{"location":"course/section_04/#arithmetic-expressions","text":"These involve mathematical operations like addition, subtraction, multiplication, and division. 5 + 3 # Addition, evaluates to 8 10 - 2 # Subtraction, evaluates to 8 4 * 2 # Multiplication, evaluates to 8 16 / 2 # Division, evaluates to 8.0","title":"Arithmetic Expressions"},{"location":"course/section_04/#string-expressions","text":"These involve operations on strings, such as concatenation. \"Hello, \" + \"world!\" # Concatenation, evaluates to \"Hello, world!\"","title":"String Expressions"},{"location":"course/section_04/#boolean-expressions","text":"These involve logical operations and comparisons, resulting in a Boolean value ( True or False ). 5 > 3 # Greater than, evaluates to True 10 == 2 * 5 # Equality, evaluates to True 4 != 2 + 2 # Inequality, evaluates to False","title":"Boolean Expressions"},{"location":"course/section_04/#function-calls","text":"Expressions can also involve calling functions, which may return values. len(\"Hello\") # Function call, evaluates to 5","title":"Function Calls"},{"location":"course/section_04/#evaluating-expressions","text":"When Python encounters an expression, it evaluates it to produce a value. This value can then be used in further calculations, assigned to variables, or passed to functions. result = 5 + 3 # The expression 5 + 3 evaluates to 8, which is assigned to the variable result print(result) # This prints 8","title":"Evaluating Expressions"},{"location":"course/section_04/#variables","text":"A variable is a named storage location in memory that holds a value. Variables allow you to store data and refer to it later in your program. You can think of a variable as a container for data. Variables are essential because they allow you to: Store and reuse values. Make your code more readable and maintainable. Write flexible and dynamic programs.","title":"Variables"},{"location":"course/section_04/#declaring-and-initializing-variables","text":"To declare a variable, you simply assign a value to it using the equals sign ( = ). This process is called initialization. age = 16 # The variable age is assigned the value 16 name = \"Alice\" # The variable name is assigned the value \"Alice\" is_student = True # The variable is_student is assigned the value True","title":"Declaring and Initializing Variables"},{"location":"course/section_04/#using-variables","text":"Once you have declared a variable, you can use it in expressions, pass it to functions, and modify its value. # Using variables in expressions x = 10 y = 5 sum = x + y # sum is assigned the value 15 # Passing variables to functions def greet(person): print(f\"Hello, {person}!\") greet(name) # This prints \"Hello, Alice!\" # Modifying variables count = 0 count = count + 1 # count is now 1 count += 2 # count is now 3","title":"Using Variables"},{"location":"course/section_04/#variable-naming-rules","text":"When naming variables in Python, follow these rules: Use letters (a-z, A-Z), digits (0-9), and underscores (_). Do not start a variable name with a digit. Variable names are case-sensitive ( age and Age are different variables). Choose meaningful names that describe the data they hold. Valid examples: student_name = \"John\" total_score = 95 is_enrolled = True Invalid examples: 2nd_place = \"Bob\" # Starts with a digit total-score = 95 # Uses a hyphen instead of an underscore class = \"Math\" # Uses a reserved keyword Good practice dictates that PEP8 rules for naming variables should be followed. Here's a link to it.","title":"Variable Naming Rules"},{"location":"course/section_04/#constants","text":"A constant is similar to a variable but is meant to remain unchanged throughout the program. By convention, constants are written in all uppercase letters. PI = 3.14159 MAX_STUDENTS = 30","title":"Constants"},{"location":"course/section_05/","text":"Assignments Assignment in Python is the process or tool used to store values in variables. They allow us to keep track of data and use it throughout our programs. In this section, we'll explore different types of assignments. In-Place Assignments In-place assignments allow you to update the value of a variable using its current value. This is done with special operators that combine assignment with an arithmetic operation. This process will be revisited with more detail when we cover operations in Python. In-place assignments make your code more concise and can be easier to read. Here are some examples: Addition( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0 Multiple Assignments Python allows you to assign values to multiple variables simultaneously. This can make your code more efficient and easier to read: Assigning Multiple Values at once: x, y, z = 1, 2, 3 print(x) # Output: 1 print(y) # Output: 2 print(z) # Output: 3 Unpacking Values from a List or Tuple coordinates = (4, 5) x, y = coordinates print(x) # Output: 4 print(y) # Output: 5 Two-Variable Swap Swapping the values of two variables is a common task in programming. Python makes this easy with a simple syntax. Traditional Swap Using a Temporary Variable x = 1 y = 2 temp = x x = y y = temp print(x) # Output: 2 print(y) # Output: 1 Pythonic Swap Using Multiple Assignments a = 3 b = 4 a, b = b, a # Swaps the values of a and b print(a) # Output: 4 print(b) # Output: 3 The Pythonic way of swapping values is more concise and avoids the need for a temporary variable, making your code cleaner.","title":"Assignments"},{"location":"course/section_05/#assignments","text":"Assignment in Python is the process or tool used to store values in variables. They allow us to keep track of data and use it throughout our programs. In this section, we'll explore different types of assignments.","title":"Assignments"},{"location":"course/section_05/#in-place-assignments","text":"In-place assignments allow you to update the value of a variable using its current value. This is done with special operators that combine assignment with an arithmetic operation. This process will be revisited with more detail when we cover operations in Python. In-place assignments make your code more concise and can be easier to read. Here are some examples: Addition( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0","title":"In-Place Assignments"},{"location":"course/section_05/#multiple-assignments","text":"Python allows you to assign values to multiple variables simultaneously. This can make your code more efficient and easier to read: Assigning Multiple Values at once: x, y, z = 1, 2, 3 print(x) # Output: 1 print(y) # Output: 2 print(z) # Output: 3 Unpacking Values from a List or Tuple coordinates = (4, 5) x, y = coordinates print(x) # Output: 4 print(y) # Output: 5","title":"Multiple Assignments"},{"location":"course/section_05/#two-variable-swap","text":"Swapping the values of two variables is a common task in programming. Python makes this easy with a simple syntax. Traditional Swap Using a Temporary Variable x = 1 y = 2 temp = x x = y y = temp print(x) # Output: 2 print(y) # Output: 1 Pythonic Swap Using Multiple Assignments a = 3 b = 4 a, b = b, a # Swaps the values of a and b print(a) # Output: 4 print(b) # Output: 3 The Pythonic way of swapping values is more concise and avoids the need for a temporary variable, making your code cleaner.","title":"Two-Variable Swap"},{"location":"course/section_06/","text":"Operators Operators are special symbols in Python that perform operations on values and variables. They are the building blocks of expressions, allowing you to perform calculations, comparisons, and logical operations. In this section, we'll explore different types of operators and how to use them. Arithmetic Operators Arithmetic operators are used to perform basic mathematical operations like addition, subtraction, multiplication, and division. Addition ( + ) x = 5 y = 3 result = x + y # Adds x and y print(result) # Output: 8 Subtraction ( - ) x = 10 y = 4 result = x - y # Subtracts y from x print(result) # Output: 6 Multiplication ( * ) x = 7 y = 6 result = x * y # Multiplies x by y print(result) # Output: 42 Division ( / ) x = 20 y = 4 result = x / y # Divides x by y print(result) # Output: 5.0 Floor Division ( // ) x = 20 y = 3 result = x // y # Divides x by y and returns the integer part print(result) # Output: 6 Modulus ( % ) x = 10 y = 3 result = x % y # Returns the remainder of x divided by y print(result) # Output: 1 Exponentiation( ** ) x = 2 y = 3 result = x ** y # Raises x to the power of y print(result) # Output: 8 Assignment Operators Assignment operators are used to assign values to variables. We've already seen the basics of these in the previous section, but there are also other assignment operators that are worth mentioning. Basic Assignment ( = ) x = 10 # Assigns the value 10 to x print(x) # Output: 10 Addition Assignment ( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction Assignment ( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication Assignment ( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division Assignment ( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0 Modulus Assignment ( %= ) b = 10 b %= 3 # Equivalent to b = b % 3 print(b) # Output: 1 Exponentiation Assignment ( **= ) c = 2 c **= 3 # Equivalent to c = c ** 3 print(c) # Output: 8 Floor Division Assignment ( //= ) d = 20 d //= 3 # Equivalent to d = d // 3 print(d) # Output: 6 Comparison Operators Comparison operators are used to compare two values and return a Boolean result ( True or False ). Equal to ( == ) x = 5 y = 5 result = (x == y) # Checks if x is equal to y print(result) # Output: True Not equal to ( != ) x = 5 y = 3 result = (x != y) # Checks if x is not equal to y print(result) # Output: True Greater than ( > ) x = 7 y = 4 result = (x > y) # Checks if x is greater than y print(result) # Output: True Less than ( < ) x = 2 y = 8 result = (x < y) # Checks if x is less than y print(result) # Output: True Greater than or equal to ( >= ) x = 6 y = 6 result = (x >= y) # Checks if x is greater than or equal to y print(result) # Output: True Less than or equal to ( <= ) x = 3 y = 5 result = (x <= y) # Checks if x is less than or equal to y print(result) # Output: True Logical Operators Logical operators are used to combine multiple Boolean expressions. and x = True y = False result = x and y # Checks if both x and y are True print(result) # Output: False or x = True y = False result = x or y # Checks if either x or y is True print(result) # Output: True not x = True result = not x # Inverts the value of x print(result) # Output: False Identity Operators Identity operators are used to compare the memory locations of two objects. is x = [1, 2, 3] y = x z = [1, 2, 3] print(x is y) # Output: True, because y is the same object as x print(x is z) # Output: False, because z is a different object with the same contents is not a = 10 b = 20 print(a is not b) # Output: True, because a and b are not the same object Membership Operators Membership operators are used to test if a sequence contains a certain value. in fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True, because \"banana\" is in the list not in fruits = [\"apple\", \"banana\", \"cherry\"] print(\"orange\" not in fruits) # Output: True, because \"orange\" is not in the list Bitwise Operators Bitwise operators are used to perform operations on binary numbers. AND ( & ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x & y) # Output: 1 (0001 in binary) OR ( | ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x | y) # Output: 7 (0111 in binary) XOR ( ^ ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x ^ y) # Output: 6 (0110 in binary) NOT ( ~ ) x = 5 # 0101 in binary print(~x) # Output: -6 (inverts the bits, giving 1010 in binary, which is -6 in two's complement form) Left Shift ( << ) x = 5 # 0101 in binary print(x << 1) # Output: 10 (1010 in binary, shifts bits left by 1 position) Right Shift ( >> ) x = 5 # 0101 in binary print(x >> 1) # Output: 2 (0010 in binary, shifts bits right by 1 position) Operator Precedence Operator precedence determines the order in which operators are evaluated in expressions. Operators with higher precedence are evaluated before operators with lower precedence. Arithmetic Operators x = 5 + 2 * 3 # Multiplication has higher precedence than addition print(x) # Output: 11 (2 * 3 is evaluated first, then 5 + 6) Using Parentheses to Change Precedence x = (5 + 2) * 3 # Parentheses change the order of evaluation print(x) # Output: 21 (5 + 2 is evaluated first, then 7 * 3) Combination of Different Operators x = 5 + 2 * 3 > 10 - 2 print(x) # Output: True (2 * 3 is evaluated first, then 5 + 6, then 10 - 2, finally 11 > 8) Here's a table summarizing the operator precedence in Python, from highest to lowest: Precedence Level Operators 1 (highest) () 2 ** 3 +x , -x , ~x 4 * , / , // , % 5 + , - 6 << , >> 7 & 8 ^ 9 binary or 10 in , not in , is , is not , < , <= , > , >= , != , == 11 not x 12 and 13 (lowest) or","title":"Operators"},{"location":"course/section_06/#operators","text":"Operators are special symbols in Python that perform operations on values and variables. They are the building blocks of expressions, allowing you to perform calculations, comparisons, and logical operations. In this section, we'll explore different types of operators and how to use them.","title":"Operators"},{"location":"course/section_06/#arithmetic-operators","text":"Arithmetic operators are used to perform basic mathematical operations like addition, subtraction, multiplication, and division.","title":"Arithmetic Operators"},{"location":"course/section_06/#addition","text":"x = 5 y = 3 result = x + y # Adds x and y print(result) # Output: 8","title":"Addition (+)"},{"location":"course/section_06/#subtraction-","text":"x = 10 y = 4 result = x - y # Subtracts y from x print(result) # Output: 6","title":"Subtraction (-)"},{"location":"course/section_06/#multiplication","text":"x = 7 y = 6 result = x * y # Multiplies x by y print(result) # Output: 42","title":"Multiplication (*)"},{"location":"course/section_06/#division","text":"x = 20 y = 4 result = x / y # Divides x by y print(result) # Output: 5.0","title":"Division (/)"},{"location":"course/section_06/#floor-division","text":"x = 20 y = 3 result = x // y # Divides x by y and returns the integer part print(result) # Output: 6","title":"Floor Division (//)"},{"location":"course/section_06/#modulus","text":"x = 10 y = 3 result = x % y # Returns the remainder of x divided by y print(result) # Output: 1","title":"Modulus (%)"},{"location":"course/section_06/#exponentiation","text":"x = 2 y = 3 result = x ** y # Raises x to the power of y print(result) # Output: 8","title":"Exponentiation(**)"},{"location":"course/section_06/#assignment-operators","text":"Assignment operators are used to assign values to variables. We've already seen the basics of these in the previous section, but there are also other assignment operators that are worth mentioning.","title":"Assignment Operators"},{"location":"course/section_06/#basic-assignment","text":"x = 10 # Assigns the value 10 to x print(x) # Output: 10","title":"Basic Assignment (=)"},{"location":"course/section_06/#addition-assignment","text":"x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8","title":"Addition Assignment (+=)"},{"location":"course/section_06/#subtraction-assignment-","text":"y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6","title":"Subtraction Assignment (-=)"},{"location":"course/section_06/#multiplication-assignment","text":"z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14","title":"Multiplication Assignment (*=)"},{"location":"course/section_06/#division-assignment","text":"a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0","title":"Division Assignment (/=)"},{"location":"course/section_06/#modulus-assignment","text":"b = 10 b %= 3 # Equivalent to b = b % 3 print(b) # Output: 1","title":"Modulus Assignment (%=)"},{"location":"course/section_06/#exponentiation-assignment","text":"c = 2 c **= 3 # Equivalent to c = c ** 3 print(c) # Output: 8","title":"Exponentiation Assignment (**=)"},{"location":"course/section_06/#floor-division-assignment","text":"d = 20 d //= 3 # Equivalent to d = d // 3 print(d) # Output: 6","title":"Floor Division Assignment (//=)"},{"location":"course/section_06/#comparison-operators","text":"Comparison operators are used to compare two values and return a Boolean result ( True or False ).","title":"Comparison Operators"},{"location":"course/section_06/#equal-to","text":"x = 5 y = 5 result = (x == y) # Checks if x is equal to y print(result) # Output: True","title":"Equal to (==)"},{"location":"course/section_06/#not-equal-to","text":"x = 5 y = 3 result = (x != y) # Checks if x is not equal to y print(result) # Output: True","title":"Not equal to (!=)"},{"location":"course/section_06/#greater-than","text":"x = 7 y = 4 result = (x > y) # Checks if x is greater than y print(result) # Output: True","title":"Greater than (&gt;)"},{"location":"course/section_06/#less-than","text":"x = 2 y = 8 result = (x < y) # Checks if x is less than y print(result) # Output: True","title":"Less than (&lt;)"},{"location":"course/section_06/#greater-than-or-equal-to","text":"x = 6 y = 6 result = (x >= y) # Checks if x is greater than or equal to y print(result) # Output: True","title":"Greater than or equal to (&gt;=)"},{"location":"course/section_06/#less-than-or-equal-to","text":"x = 3 y = 5 result = (x <= y) # Checks if x is less than or equal to y print(result) # Output: True","title":"Less than or equal to (&lt;=)"},{"location":"course/section_06/#logical-operators","text":"Logical operators are used to combine multiple Boolean expressions.","title":"Logical Operators"},{"location":"course/section_06/#and","text":"x = True y = False result = x and y # Checks if both x and y are True print(result) # Output: False","title":"and"},{"location":"course/section_06/#or","text":"x = True y = False result = x or y # Checks if either x or y is True print(result) # Output: True","title":"or"},{"location":"course/section_06/#not","text":"x = True result = not x # Inverts the value of x print(result) # Output: False","title":"not"},{"location":"course/section_06/#identity-operators","text":"Identity operators are used to compare the memory locations of two objects.","title":"Identity Operators"},{"location":"course/section_06/#is","text":"x = [1, 2, 3] y = x z = [1, 2, 3] print(x is y) # Output: True, because y is the same object as x print(x is z) # Output: False, because z is a different object with the same contents","title":"is"},{"location":"course/section_06/#is-not","text":"a = 10 b = 20 print(a is not b) # Output: True, because a and b are not the same object","title":"is not"},{"location":"course/section_06/#membership-operators","text":"Membership operators are used to test if a sequence contains a certain value.","title":"Membership Operators"},{"location":"course/section_06/#in","text":"fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True, because \"banana\" is in the list","title":"in"},{"location":"course/section_06/#not-in","text":"fruits = [\"apple\", \"banana\", \"cherry\"] print(\"orange\" not in fruits) # Output: True, because \"orange\" is not in the list","title":"not in"},{"location":"course/section_06/#bitwise-operators","text":"Bitwise operators are used to perform operations on binary numbers.","title":"Bitwise Operators"},{"location":"course/section_06/#and_1","text":"x = 5 # 0101 in binary y = 3 # 0011 in binary print(x & y) # Output: 1 (0001 in binary)","title":"AND (&amp;)"},{"location":"course/section_06/#or_1","text":"x = 5 # 0101 in binary y = 3 # 0011 in binary print(x | y) # Output: 7 (0111 in binary)","title":"OR (|)"},{"location":"course/section_06/#xor","text":"x = 5 # 0101 in binary y = 3 # 0011 in binary print(x ^ y) # Output: 6 (0110 in binary)","title":"XOR (^)"},{"location":"course/section_06/#not_1","text":"x = 5 # 0101 in binary print(~x) # Output: -6 (inverts the bits, giving 1010 in binary, which is -6 in two's complement form)","title":"NOT (~)"},{"location":"course/section_06/#left-shift","text":"x = 5 # 0101 in binary print(x << 1) # Output: 10 (1010 in binary, shifts bits left by 1 position)","title":"Left Shift (&lt;&lt;)"},{"location":"course/section_06/#right-shift","text":"x = 5 # 0101 in binary print(x >> 1) # Output: 2 (0010 in binary, shifts bits right by 1 position)","title":"Right Shift (&gt;&gt;)"},{"location":"course/section_06/#operator-precedence","text":"Operator precedence determines the order in which operators are evaluated in expressions. Operators with higher precedence are evaluated before operators with lower precedence. Arithmetic Operators x = 5 + 2 * 3 # Multiplication has higher precedence than addition print(x) # Output: 11 (2 * 3 is evaluated first, then 5 + 6) Using Parentheses to Change Precedence x = (5 + 2) * 3 # Parentheses change the order of evaluation print(x) # Output: 21 (5 + 2 is evaluated first, then 7 * 3) Combination of Different Operators x = 5 + 2 * 3 > 10 - 2 print(x) # Output: True (2 * 3 is evaluated first, then 5 + 6, then 10 - 2, finally 11 > 8) Here's a table summarizing the operator precedence in Python, from highest to lowest: Precedence Level Operators 1 (highest) () 2 ** 3 +x , -x , ~x 4 * , / , // , % 5 + , - 6 << , >> 7 & 8 ^ 9 binary or 10 in , not in , is , is not , < , <= , > , >= , != , == 11 not x 12 and 13 (lowest) or","title":"Operator Precedence"},{"location":"course/section_07/","text":"Functions Functions are one of the most important building blocks in Python. They allow you to group code into reusable blocks, making your programs more modular, readable, and maintainable. A function is a block of code that performs a specific task. Functions help you to avoid repeating code by allowing you to define it once and reuse it as needed. Functions can take inputs, perform operations, and return outputs. Defining a Function To define a function in Python, use the def keyword followed by the function name and parentheses () which may include parameters. def greet(name): print(f\"Hello, {name}!\") Calling a Function To call a function, simply use its name followed by parentheses, including any arguments required by the function. greet(\"Alice\") # Output: Hello, Alice! Parameters and Arguments Parameters are variables defined in the function signature. Arguments are the values you pass to the function when you call it. def add(a, b): return a + b result = add(3, 4) # Arguments 3 and 4 are passed to parameters a and b print(result) # Output: 7 Return Statement The return statement is used to send a result back from the function to the caller. Once return is executed, the function terminates. def square(x): return x * x result = square(5) print(result) # Output: 25 Call Stack The call stack is a mechanism that keeps track of function calls. When a function is called, a frame is added to the stack. When the function returns, the frame is removed. The call stack helps manage the order in which functions are executed and their respective scopes. def func1(): print(\"Start func1\") func2() print(\"End func1\") def func2(): print(\"Start func2\") func3() print(\"End func2\") def func3(): print(\"Start func3\") print(\"End func3\") func1() Output: Start func1 Start func2 Start func3 End func3 End func2 End func1 In this example, func1 calls func2 , and func2 calls func3 . The call stack manages these calls and ensures each function returns in the correct order. Traceback A traceback is a report that Python generates when an error occurs in your program. It shows the call stack at the point where the error happened, helping you to diagnose and fix issues. def divide(x, y): return x / y result = divide(10, 0) Output: Traceback (most recent call last): File \"example.py\", line 5, in <module> result = divide(10, 0) File \"example.py\", line 2, in divide return x / y ZeroDivisionError: division by zero The traceback shows that the error occurred in the divide function because of a division by zero. Function Scope and Lifetime Variables defined inside a function are local to that function. They exist only during the function's execution and are not accessible outside. def func(): x = 10 # x is local to func print(x) func() print(x) # Error: x is not defined outside func Recursive Functions A function that calls itself is known as a recursive function. Recursion can be used to solve problems that can be broken down into simpler, repetitive tasks. This will be a concept we will work in depth later on during this course. def factorial(n): if n == 1: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120","title":"Functions"},{"location":"course/section_07/#functions","text":"Functions are one of the most important building blocks in Python. They allow you to group code into reusable blocks, making your programs more modular, readable, and maintainable. A function is a block of code that performs a specific task. Functions help you to avoid repeating code by allowing you to define it once and reuse it as needed. Functions can take inputs, perform operations, and return outputs.","title":"Functions"},{"location":"course/section_07/#defining-a-function","text":"To define a function in Python, use the def keyword followed by the function name and parentheses () which may include parameters. def greet(name): print(f\"Hello, {name}!\")","title":"Defining a Function"},{"location":"course/section_07/#calling-a-function","text":"To call a function, simply use its name followed by parentheses, including any arguments required by the function. greet(\"Alice\") # Output: Hello, Alice!","title":"Calling a Function"},{"location":"course/section_07/#parameters-and-arguments","text":"Parameters are variables defined in the function signature. Arguments are the values you pass to the function when you call it. def add(a, b): return a + b result = add(3, 4) # Arguments 3 and 4 are passed to parameters a and b print(result) # Output: 7","title":"Parameters and Arguments"},{"location":"course/section_07/#return-statement","text":"The return statement is used to send a result back from the function to the caller. Once return is executed, the function terminates. def square(x): return x * x result = square(5) print(result) # Output: 25","title":"Return Statement"},{"location":"course/section_07/#call-stack","text":"The call stack is a mechanism that keeps track of function calls. When a function is called, a frame is added to the stack. When the function returns, the frame is removed. The call stack helps manage the order in which functions are executed and their respective scopes. def func1(): print(\"Start func1\") func2() print(\"End func1\") def func2(): print(\"Start func2\") func3() print(\"End func2\") def func3(): print(\"Start func3\") print(\"End func3\") func1() Output: Start func1 Start func2 Start func3 End func3 End func2 End func1 In this example, func1 calls func2 , and func2 calls func3 . The call stack manages these calls and ensures each function returns in the correct order.","title":"Call Stack"},{"location":"course/section_07/#traceback","text":"A traceback is a report that Python generates when an error occurs in your program. It shows the call stack at the point where the error happened, helping you to diagnose and fix issues. def divide(x, y): return x / y result = divide(10, 0) Output: Traceback (most recent call last): File \"example.py\", line 5, in <module> result = divide(10, 0) File \"example.py\", line 2, in divide return x / y ZeroDivisionError: division by zero The traceback shows that the error occurred in the divide function because of a division by zero.","title":"Traceback"},{"location":"course/section_07/#function-scope-and-lifetime","text":"Variables defined inside a function are local to that function. They exist only during the function's execution and are not accessible outside. def func(): x = 10 # x is local to func print(x) func() print(x) # Error: x is not defined outside func","title":"Function Scope and Lifetime"},{"location":"course/section_07/#recursive-functions","text":"A function that calls itself is known as a recursive function. Recursion can be used to solve problems that can be broken down into simpler, repetitive tasks. This will be a concept we will work in depth later on during this course. def factorial(n): if n == 1: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120","title":"Recursive Functions"},{"location":"course/section_08/","text":"Conditionals Conditionals allow you to execute different code based on certain conditions. They are fundamental to controlling the flow of your programs, making decisions, and performing actions based on those decisions. If Statements The if statement is used to test a condition. If the condition is True , the code block inside the if statement is executed. age = 18 if age >= 18: print(\"You are an adult.\") Else Statements The else statement is used in conjunction with the if statement. It defines a block of code that will be executed if the if condition is False . age = 16 if age >= 18: print(\"You are an adult.\") else: print(\"You are a minor.\") Elif Statements The elif (short for \"else if\") statement allows you to check multiple conditions. If the first if condition is False , the program checks the elif conditions in order. If one of the elif conditions is True , its block of code is executed. score = 85 if score >= 90: print(\"Grade: A\") elif score >= 80: print(\"Grade: B\") elif score >= 70: print(\"Grade: C\") elif score >= 60: print(\"Grade: D\") else: print(\"Grade: F\") Nested If Statements You can nest if , elif , and else statements inside other if , elif , and else statements to create more complex conditions. num = 15 if num % 2 == 0: print(\"The number is even.\") else: print(\"The number is odd.\") if num % 3 == 0: print(\"The number is also divisible by 3.\") Conditional Expressions (Ternary Operator) A conditional expression, also known as a ternary operator, allows you to write a simple if-else statement in one line. age = 18 status = \"adult\" if age >= 18 else \"minor\" print(status) # Output: adult Combining Conditions You can combine multiple conditions using logical operators and , or , and not to create more complex conditional statements. Using and : num = 10 if num > 5 and num < 15: print(\"The number is between 5 and 15.\") Using or : day = \"Saturday\" if day == \"Saturday\" or day == \"Sunday\": print(\"It's the weekend!\") Using not : is_raining = False if not is_raining: print(\"It's not raining, you can go outside.\")","title":"Conditionals"},{"location":"course/section_08/#conditionals","text":"Conditionals allow you to execute different code based on certain conditions. They are fundamental to controlling the flow of your programs, making decisions, and performing actions based on those decisions.","title":"Conditionals"},{"location":"course/section_08/#if-statements","text":"The if statement is used to test a condition. If the condition is True , the code block inside the if statement is executed. age = 18 if age >= 18: print(\"You are an adult.\")","title":"If Statements"},{"location":"course/section_08/#else-statements","text":"The else statement is used in conjunction with the if statement. It defines a block of code that will be executed if the if condition is False . age = 16 if age >= 18: print(\"You are an adult.\") else: print(\"You are a minor.\")","title":"Else Statements"},{"location":"course/section_08/#elif-statements","text":"The elif (short for \"else if\") statement allows you to check multiple conditions. If the first if condition is False , the program checks the elif conditions in order. If one of the elif conditions is True , its block of code is executed. score = 85 if score >= 90: print(\"Grade: A\") elif score >= 80: print(\"Grade: B\") elif score >= 70: print(\"Grade: C\") elif score >= 60: print(\"Grade: D\") else: print(\"Grade: F\")","title":"Elif Statements"},{"location":"course/section_08/#nested-if-statements","text":"You can nest if , elif , and else statements inside other if , elif , and else statements to create more complex conditions. num = 15 if num % 2 == 0: print(\"The number is even.\") else: print(\"The number is odd.\") if num % 3 == 0: print(\"The number is also divisible by 3.\")","title":"Nested If Statements"},{"location":"course/section_08/#conditional-expressions-ternary-operator","text":"A conditional expression, also known as a ternary operator, allows you to write a simple if-else statement in one line. age = 18 status = \"adult\" if age >= 18 else \"minor\" print(status) # Output: adult","title":"Conditional Expressions (Ternary Operator)"},{"location":"course/section_08/#combining-conditions","text":"You can combine multiple conditions using logical operators and , or , and not to create more complex conditional statements. Using and : num = 10 if num > 5 and num < 15: print(\"The number is between 5 and 15.\") Using or : day = \"Saturday\" if day == \"Saturday\" or day == \"Sunday\": print(\"It's the weekend!\") Using not : is_raining = False if not is_raining: print(\"It's not raining, you can go outside.\")","title":"Combining Conditions"},{"location":"course/section_09/","text":"Lists Lists are one of the most versatile and commonly used data structures in Python. They allow you to store collections of items in a single variable, making it easy to organize and manipulate data. Creating Lists A list is created by placing all the items (elements) inside square brackets [] , separated by commas. # A list of integers numbers = [1, 2, 3, 4, 5] # A list of strings fruits = [\"apple\", \"banana\", \"cherry\"] # A mixed list mixed = [1, \"hello\", 3.14, True] Accessing List Elements You can access individual elements in a list using their index. Python uses zero-based indexing, meaning the first element has an index of 0. fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple print(fruits[2]) # Output: cherry # Accessing elements from the end print(fruits[-1]) # Output: cherry print(fruits[-2]) # Output: banana Modifying Lists Lists are mutable, meaning you can change their elements after they have been created. fruits = [\"apple\", \"banana\", \"cherry\"] # Changing an element fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry'] # Adding elements fruits.append(\"date\") print(fruits) # Output: ['apple', 'blueberry', 'cherry', 'date'] # Inserting elements fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'blueberry', 'cherry', 'date'] # Removing elements fruits.remove(\"blueberry\") print(fruits) # Output: ['apple', 'banana', 'cherry', 'date'] List Operations Python provides many built-in methods and operations that you can use to manipulate lists. Length numbers = [1, 2, 3, 4, 5] print(len(numbers)) # Output: 5 Concatenation list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6] Repetition fruits = [\"apple\", \"banana\"] print(fruits * 3) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana'] Slicing numbers = [1, 2, 3, 4, 5] print(numbers[1:4]) # Output: [2, 3, 4] print(numbers[:3]) # Output: [1, 2, 3] print(numbers[2:]) # Output: [3, 4, 5] Checking Membership fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"date\" not in fruits) # Output: True List Comprehensions List comprehensions are perhaps one of the most powerful tools offered by Python. They provide a concise way to create lists. They can be used to generate new lists by applying an expression to each element in an existing list. # Creating a list of squares squares = [x ** 2 for x in range(1, 6)] print(squares) # Output: [1, 4, 9, 16, 25] Common List Methods append() Adds an element to the end of the list. fruits = [\"apple\", \"banana\"] fruits.append(\"cherry\") print(fruits) # Output: ['apple', 'banana', 'cherry'] insert() Inserts an element at a specified position. fruits = [\"apple\", \"cherry\"] fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'cherry'] remove() Removes the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] fruits.remove(\"banana\") print(fruits) # Output: ['apple', 'cherry'] pop() Removes and returns the element at a specified position (default is the last element). fruits = [\"apple\", \"banana\", \"cherry\"] fruit = fruits.pop() print(fruit) # Output: cherry print(fruits) # Output: ['apple', 'banana'] index() Returns the index of the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] index = fruits.index(\"banana\") print(index) # Output: 1 count() Returns the number of times a specified element appears in the list. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] count = fruits.count(\"banana\") print(count) # Output: 2 sort() Sorts the list in ascending order. numbers = [4, 2, 3, 1, 5] numbers.sort() print(numbers) # Output: [1, 2, 3, 4, 5] reverse() Reverses the order of the list. numbers = [1, 2, 3, 4, 5] numbers.reverse() print(numbers) # Output: [5, 4, 3, 2, 1]","title":"Lists"},{"location":"course/section_09/#lists","text":"Lists are one of the most versatile and commonly used data structures in Python. They allow you to store collections of items in a single variable, making it easy to organize and manipulate data.","title":"Lists"},{"location":"course/section_09/#creating-lists","text":"A list is created by placing all the items (elements) inside square brackets [] , separated by commas. # A list of integers numbers = [1, 2, 3, 4, 5] # A list of strings fruits = [\"apple\", \"banana\", \"cherry\"] # A mixed list mixed = [1, \"hello\", 3.14, True]","title":"Creating Lists"},{"location":"course/section_09/#accessing-list-elements","text":"You can access individual elements in a list using their index. Python uses zero-based indexing, meaning the first element has an index of 0. fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple print(fruits[2]) # Output: cherry # Accessing elements from the end print(fruits[-1]) # Output: cherry print(fruits[-2]) # Output: banana","title":"Accessing List Elements"},{"location":"course/section_09/#modifying-lists","text":"Lists are mutable, meaning you can change their elements after they have been created. fruits = [\"apple\", \"banana\", \"cherry\"] # Changing an element fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry'] # Adding elements fruits.append(\"date\") print(fruits) # Output: ['apple', 'blueberry', 'cherry', 'date'] # Inserting elements fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'blueberry', 'cherry', 'date'] # Removing elements fruits.remove(\"blueberry\") print(fruits) # Output: ['apple', 'banana', 'cherry', 'date']","title":"Modifying Lists"},{"location":"course/section_09/#list-operations","text":"Python provides many built-in methods and operations that you can use to manipulate lists.","title":"List Operations"},{"location":"course/section_09/#length","text":"numbers = [1, 2, 3, 4, 5] print(len(numbers)) # Output: 5","title":"Length"},{"location":"course/section_09/#concatenation","text":"list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6]","title":"Concatenation"},{"location":"course/section_09/#repetition","text":"fruits = [\"apple\", \"banana\"] print(fruits * 3) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana']","title":"Repetition"},{"location":"course/section_09/#slicing","text":"numbers = [1, 2, 3, 4, 5] print(numbers[1:4]) # Output: [2, 3, 4] print(numbers[:3]) # Output: [1, 2, 3] print(numbers[2:]) # Output: [3, 4, 5]","title":"Slicing"},{"location":"course/section_09/#checking-membership","text":"fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"date\" not in fruits) # Output: True","title":"Checking Membership"},{"location":"course/section_09/#list-comprehensions","text":"List comprehensions are perhaps one of the most powerful tools offered by Python. They provide a concise way to create lists. They can be used to generate new lists by applying an expression to each element in an existing list. # Creating a list of squares squares = [x ** 2 for x in range(1, 6)] print(squares) # Output: [1, 4, 9, 16, 25]","title":"List Comprehensions"},{"location":"course/section_09/#common-list-methods","text":"","title":"Common List Methods"},{"location":"course/section_09/#append","text":"Adds an element to the end of the list. fruits = [\"apple\", \"banana\"] fruits.append(\"cherry\") print(fruits) # Output: ['apple', 'banana', 'cherry']","title":"append()"},{"location":"course/section_09/#insert","text":"Inserts an element at a specified position. fruits = [\"apple\", \"cherry\"] fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'cherry']","title":"insert()"},{"location":"course/section_09/#remove","text":"Removes the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] fruits.remove(\"banana\") print(fruits) # Output: ['apple', 'cherry']","title":"remove()"},{"location":"course/section_09/#pop","text":"Removes and returns the element at a specified position (default is the last element). fruits = [\"apple\", \"banana\", \"cherry\"] fruit = fruits.pop() print(fruit) # Output: cherry print(fruits) # Output: ['apple', 'banana']","title":"pop()"},{"location":"course/section_09/#index","text":"Returns the index of the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] index = fruits.index(\"banana\") print(index) # Output: 1","title":"index()"},{"location":"course/section_09/#count","text":"Returns the number of times a specified element appears in the list. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] count = fruits.count(\"banana\") print(count) # Output: 2","title":"count()"},{"location":"course/section_09/#sort","text":"Sorts the list in ascending order. numbers = [4, 2, 3, 1, 5] numbers.sort() print(numbers) # Output: [1, 2, 3, 4, 5]","title":"sort()"},{"location":"course/section_09/#reverse","text":"Reverses the order of the list. numbers = [1, 2, 3, 4, 5] numbers.reverse() print(numbers) # Output: [5, 4, 3, 2, 1]","title":"reverse()"},{"location":"course/section_10/","text":"Loops Loops allow you to execute a block of code multiple times, making your programs more efficient and reducing the need for repetitive code. In Python, there are two main types of loops: for loops and while loops. for Loops A for loop is used to iterate over a sequence (such as a list, tuple, string, or range) and execute a block of code for each item in the sequence. Here's the syntax of a for loop: for variable in sequence: # Code to execute for each item Usage: Iterating Over a List: fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(fruit) Using the range() Function: for i in range(5): print(i) Iterating Over a String: for letter in \"hello\": print(letter) while Loops A while loop continues to execute as long as a specified condition is True . It is useful when the number of iterations is not known beforehand. Here's the syntax of a while loop: while condition: # Code to execute while the condition is True Usage: Basic while Loop: count = 0 while count < 5: print(count) count += 1 Using a while Loop for User Input: user_input = \"\" while user_input != \"exit\": user_input = input(\"Type 'exit' to stop: \") Nested Loops You can nest loops inside other loops to perform more complex iterations. Each iteration of the outer loop triggers the complete execution of the inner loop. for i in range(3): for j in range(2): print(f\"i = {i}, j = {j}\") Loop Control Statements Python provides several statements to control the execution of loops: break Terminates the loop prematurely. for i in range(10): if i == 5: break print(i) continue Skips the current iteration and proceeds to the next iteration. for i in range(5): if i == 3: continue print(i) for/else loop Executes a block of code after the loop finishes, unless the loop is terminated by a break statement. for item in container: if search_something(item): # Found it! process(item) break else: # Didn't find anything.. not_found_in_container() Using Loops with Lists Loops are often used to iterate over lists and perform operations on each element. Calculating the Sum of a List: numbers = [1, 2, 3, 4, 5] total = 0 for number in numbers: total += number print(\"Total:\", total) Finding the Maximum Element in a List: numbers = [3, 7, 2, 5, 9] max_number = numbers[0] for number in numbers: if number > max_number: max_number = number print(\"Maximum number:\", max_number) Using a while Loop to Create a List: even_numbers = [] num = 2 while num <= 10: even_numbers.append(num) num += 2 print(\"Even numbers:\", even_numbers)","title":"Loops"},{"location":"course/section_10/#loops","text":"Loops allow you to execute a block of code multiple times, making your programs more efficient and reducing the need for repetitive code. In Python, there are two main types of loops: for loops and while loops.","title":"Loops"},{"location":"course/section_10/#for-loops","text":"A for loop is used to iterate over a sequence (such as a list, tuple, string, or range) and execute a block of code for each item in the sequence. Here's the syntax of a for loop: for variable in sequence: # Code to execute for each item","title":"for Loops"},{"location":"course/section_10/#usage","text":"Iterating Over a List: fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(fruit) Using the range() Function: for i in range(5): print(i) Iterating Over a String: for letter in \"hello\": print(letter)","title":"Usage:"},{"location":"course/section_10/#while-loops","text":"A while loop continues to execute as long as a specified condition is True . It is useful when the number of iterations is not known beforehand. Here's the syntax of a while loop: while condition: # Code to execute while the condition is True","title":"while Loops"},{"location":"course/section_10/#usage_1","text":"Basic while Loop: count = 0 while count < 5: print(count) count += 1 Using a while Loop for User Input: user_input = \"\" while user_input != \"exit\": user_input = input(\"Type 'exit' to stop: \")","title":"Usage:"},{"location":"course/section_10/#nested-loops","text":"You can nest loops inside other loops to perform more complex iterations. Each iteration of the outer loop triggers the complete execution of the inner loop. for i in range(3): for j in range(2): print(f\"i = {i}, j = {j}\")","title":"Nested Loops"},{"location":"course/section_10/#loop-control-statements","text":"Python provides several statements to control the execution of loops:","title":"Loop Control Statements"},{"location":"course/section_10/#break","text":"Terminates the loop prematurely. for i in range(10): if i == 5: break print(i)","title":"break"},{"location":"course/section_10/#continue","text":"Skips the current iteration and proceeds to the next iteration. for i in range(5): if i == 3: continue print(i)","title":"continue"},{"location":"course/section_10/#forelse-loop","text":"Executes a block of code after the loop finishes, unless the loop is terminated by a break statement. for item in container: if search_something(item): # Found it! process(item) break else: # Didn't find anything.. not_found_in_container()","title":"for/else loop"},{"location":"course/section_10/#using-loops-with-lists","text":"Loops are often used to iterate over lists and perform operations on each element. Calculating the Sum of a List: numbers = [1, 2, 3, 4, 5] total = 0 for number in numbers: total += number print(\"Total:\", total) Finding the Maximum Element in a List: numbers = [3, 7, 2, 5, 9] max_number = numbers[0] for number in numbers: if number > max_number: max_number = number print(\"Maximum number:\", max_number) Using a while Loop to Create a List: even_numbers = [] num = 2 while num <= 10: even_numbers.append(num) num += 2 print(\"Even numbers:\", even_numbers)","title":"Using Loops with Lists"},{"location":"course/section_11/","text":"Boolean Expressions Boolean expressions are expressions that evaluate to either True or False . They are fundamental to decision-making in programming, allowing you to control the flow of your code based on conditions. Boolean Values Python has two boolean values: True and False . These values are the result of boolean expressions and are used in conditional statements, loops, and other control structures. is_raining = True is_sunny = False Pythonic Booleans Python has a concept of \"truthy\" and \"falsy\" values, where certain values are implicitly converted to True or False in a boolean context. Truthy Values Non-zero numbers Non-empty strings Non-empty collections (lists, tuples, dictionaries, etc.) Falsy Values None False Zero ( 0 , 0.0 , 0j ) Empty strings ( \"\" ) Empty collections ( [] , () , {} ) if 0: print(\"This is truthy.\") else: print(\"This is falsy.\") # Output: This is falsy. if \"hello\": print(\"This is truthy.\") # Output: This is truthy. else: print(\"This is falsy.\") Shortcutting Shortcutting (short-circuit evaluation) is a feature in Python where logical operators and and or stop evaluating as soon as the result is determined. This can make your code more efficient by avoiding unnecessary computations. AND Shortcutting In an AND operation, if any operand is False , the whole expression is False , and evaluation stops immediately. a = False b = True result = a and b print(result) # Output: False Here, a is False , so b is not evaluated because the result is already determined to be False . OR Shortcutting In an OR operation, if any operand is True , the whole expression is True , and evaluation stops immediately. a = True b = False result = a or b print(result) # Output: True Here, a is True , so b is not evaluated because the result is already determined to be True . Practical Applications: Avoiding Errors with Shortcutting: You can use shortcutting to prevent errors by ensuring that certain conditions are met before performing operations. user_input = None # Avoiding attribute error by checking for None if user_input and user_input.strip() != \"\": print(f\"User input: {user_input.strip()}\") else: print(\"No valid input provided.\") In this example, user_input.strip() is only called if user_input is not None , preventing a potential AttributeError . Conditional Execution: Use shortcutting to conditionally execute functions or expressions only when necessary. def expensive_operation(): print(\"Expensive operation executed.\") return True condition = False # Expensive operation will not execute because condition is False result = condition and expensive_operation() print(result) # Output: False In this example, expensive_operation is not called because condition is False . Setting Default Values: Use shortcutting with the or operator to provide default values. primary_value = None secondary_value = \"Secondary\" default_value = \"Default\" # Uses secondary_value because primary_value is None result = primary_value or secondary_value or default_value print(result) # Output: Secondary Here, secondary_value is used because primary_value is None . Input Validation: Use shortcutting to validate multiple conditions in user input. password = \"mypassword123\" # Check if password is valid: at least 8 characters, contains a digit, and contains a letter is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if all conditions are true. If the first condition fails, the subsequent checks are not performed. Short-Circuiting with Function Calls: Use shortcutting to decide whether to call a function based on certain conditions. def greet(): print(\"Hello!\") name = \"Alice\" # Greet only if name is not empty name and greet() # Output: Hello! In this example, greet() is called only if name is not an empty string. Summary: Shortcutting allows you to optimize your code by stopping evaluation as soon as the result is determined. This feature is useful for preventing errors, improving performance, and making your code more concise. By understanding how shortcutting works, you can effectively use it to handle conditional execution, validate inputs, and manage complex logical flows in your programs. Chaining You can chain multiple comparisons together in a single expression. x = 5 print(1 < x < 10) # Output: True print(10 < x < 20) # Output: False The idea here is that the first value that defines the result in a chained expression is returned: a or b or c or d a and b and c and d Applications: Finding the First Truthy Value (OR Chaining): In an OR chain, the first truthy value is returned, or the last value if none are truthy. a = None b = \"\" c = 0 d = \"Python\" result = a or b or c or d print(result) # Output: Python In this example, d is the first truthy value, so it is returned. Ensuring All Conditions are True (AND Chaining): In an AND chain, the first falsy value is returned, or the last value if all are truthy. a = True b = 5 > 3 c = 10 == 10 d = 0 # This is falsy result = a and b and c and d print(result) # Output: 0 In this example, d is the first falsy value, so it is returned. Default Values with OR Chaining: You can use OR chaining to provide default values if previous values are falsy. username = input(\"Enter your username: \") or \"Guest\" print(f\"Welcome, {username}!\") If the user inputs an empty string, \"Guest\" is used as the default value. Checking Multiple Conditions with AND Chaining: You can use AND chaining to ensure multiple conditions are met. age = 25 has_permission = True is_member = True if age > 18 and has_permission and is_member: print(\"Access granted.\") else: print(\"Access denied.\") In this example, access is granted only if all conditions are true. Conditional Assignment: You can use chaining to assign values based on multiple conditions. score = 85 grade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'D' if score >= 60 else 'F' print(f\"Your grade is: {grade}\") This example assigns a grade based on the score using chained comparisons. Validating User Input: Chaining can be used to validate multiple conditions in user input. password = \"mypassword123\" is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if it is at least 8 characters long, contains at least one digit, and contains at least one letter. Summary: Chaining allows you to combine multiple comparisons and logical operations into a single, concise expression. This technique is useful for simplifying code and making it more readable. By understanding how chaining works, you can effectively use it to handle default values, validate conditions, and manage complex logical flows in your programs. Boolean Return Values Functions can return boolean values, making them useful for complex conditions. Imagine we are trying to write down a function that checks if we're allowed to sleep in or not in a certain day, evaluating whether this day is a weekday or not, and if we are on vacation or not. We could write down something like this to solve the problem: def sleep_in(weekday, vacation): if weekday == True and vacation == False: return False else return True Even though the solution above is correct, it is not a pythonic way of doing things. We could do this instead: def sleep_in(weekday, vacation): return not (weekday == True and vacation == False)","title":"Boolean Expressions"},{"location":"course/section_11/#boolean-expressions","text":"Boolean expressions are expressions that evaluate to either True or False . They are fundamental to decision-making in programming, allowing you to control the flow of your code based on conditions.","title":"Boolean Expressions"},{"location":"course/section_11/#boolean-values","text":"Python has two boolean values: True and False . These values are the result of boolean expressions and are used in conditional statements, loops, and other control structures. is_raining = True is_sunny = False","title":"Boolean Values"},{"location":"course/section_11/#pythonic-booleans","text":"Python has a concept of \"truthy\" and \"falsy\" values, where certain values are implicitly converted to True or False in a boolean context.","title":"Pythonic Booleans"},{"location":"course/section_11/#truthy-values","text":"Non-zero numbers Non-empty strings Non-empty collections (lists, tuples, dictionaries, etc.)","title":"Truthy Values"},{"location":"course/section_11/#falsy-values","text":"None False Zero ( 0 , 0.0 , 0j ) Empty strings ( \"\" ) Empty collections ( [] , () , {} ) if 0: print(\"This is truthy.\") else: print(\"This is falsy.\") # Output: This is falsy. if \"hello\": print(\"This is truthy.\") # Output: This is truthy. else: print(\"This is falsy.\")","title":"Falsy Values"},{"location":"course/section_11/#shortcutting","text":"Shortcutting (short-circuit evaluation) is a feature in Python where logical operators and and or stop evaluating as soon as the result is determined. This can make your code more efficient by avoiding unnecessary computations.","title":"Shortcutting"},{"location":"course/section_11/#and-shortcutting","text":"In an AND operation, if any operand is False , the whole expression is False , and evaluation stops immediately. a = False b = True result = a and b print(result) # Output: False Here, a is False , so b is not evaluated because the result is already determined to be False .","title":"AND Shortcutting"},{"location":"course/section_11/#or-shortcutting","text":"In an OR operation, if any operand is True , the whole expression is True , and evaluation stops immediately. a = True b = False result = a or b print(result) # Output: True Here, a is True , so b is not evaluated because the result is already determined to be True .","title":"OR Shortcutting"},{"location":"course/section_11/#practical-applications","text":"Avoiding Errors with Shortcutting: You can use shortcutting to prevent errors by ensuring that certain conditions are met before performing operations. user_input = None # Avoiding attribute error by checking for None if user_input and user_input.strip() != \"\": print(f\"User input: {user_input.strip()}\") else: print(\"No valid input provided.\") In this example, user_input.strip() is only called if user_input is not None , preventing a potential AttributeError . Conditional Execution: Use shortcutting to conditionally execute functions or expressions only when necessary. def expensive_operation(): print(\"Expensive operation executed.\") return True condition = False # Expensive operation will not execute because condition is False result = condition and expensive_operation() print(result) # Output: False In this example, expensive_operation is not called because condition is False . Setting Default Values: Use shortcutting with the or operator to provide default values. primary_value = None secondary_value = \"Secondary\" default_value = \"Default\" # Uses secondary_value because primary_value is None result = primary_value or secondary_value or default_value print(result) # Output: Secondary Here, secondary_value is used because primary_value is None . Input Validation: Use shortcutting to validate multiple conditions in user input. password = \"mypassword123\" # Check if password is valid: at least 8 characters, contains a digit, and contains a letter is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if all conditions are true. If the first condition fails, the subsequent checks are not performed. Short-Circuiting with Function Calls: Use shortcutting to decide whether to call a function based on certain conditions. def greet(): print(\"Hello!\") name = \"Alice\" # Greet only if name is not empty name and greet() # Output: Hello! In this example, greet() is called only if name is not an empty string.","title":"Practical Applications:"},{"location":"course/section_11/#summary","text":"Shortcutting allows you to optimize your code by stopping evaluation as soon as the result is determined. This feature is useful for preventing errors, improving performance, and making your code more concise. By understanding how shortcutting works, you can effectively use it to handle conditional execution, validate inputs, and manage complex logical flows in your programs.","title":"Summary:"},{"location":"course/section_11/#chaining","text":"You can chain multiple comparisons together in a single expression. x = 5 print(1 < x < 10) # Output: True print(10 < x < 20) # Output: False The idea here is that the first value that defines the result in a chained expression is returned: a or b or c or d a and b and c and d","title":"Chaining"},{"location":"course/section_11/#applications","text":"Finding the First Truthy Value (OR Chaining): In an OR chain, the first truthy value is returned, or the last value if none are truthy. a = None b = \"\" c = 0 d = \"Python\" result = a or b or c or d print(result) # Output: Python In this example, d is the first truthy value, so it is returned. Ensuring All Conditions are True (AND Chaining): In an AND chain, the first falsy value is returned, or the last value if all are truthy. a = True b = 5 > 3 c = 10 == 10 d = 0 # This is falsy result = a and b and c and d print(result) # Output: 0 In this example, d is the first falsy value, so it is returned. Default Values with OR Chaining: You can use OR chaining to provide default values if previous values are falsy. username = input(\"Enter your username: \") or \"Guest\" print(f\"Welcome, {username}!\") If the user inputs an empty string, \"Guest\" is used as the default value. Checking Multiple Conditions with AND Chaining: You can use AND chaining to ensure multiple conditions are met. age = 25 has_permission = True is_member = True if age > 18 and has_permission and is_member: print(\"Access granted.\") else: print(\"Access denied.\") In this example, access is granted only if all conditions are true. Conditional Assignment: You can use chaining to assign values based on multiple conditions. score = 85 grade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'D' if score >= 60 else 'F' print(f\"Your grade is: {grade}\") This example assigns a grade based on the score using chained comparisons. Validating User Input: Chaining can be used to validate multiple conditions in user input. password = \"mypassword123\" is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if it is at least 8 characters long, contains at least one digit, and contains at least one letter.","title":"Applications:"},{"location":"course/section_11/#summary_1","text":"Chaining allows you to combine multiple comparisons and logical operations into a single, concise expression. This technique is useful for simplifying code and making it more readable. By understanding how chaining works, you can effectively use it to handle default values, validate conditions, and manage complex logical flows in your programs.","title":"Summary:"},{"location":"course/section_11/#boolean-return-values","text":"Functions can return boolean values, making them useful for complex conditions. Imagine we are trying to write down a function that checks if we're allowed to sleep in or not in a certain day, evaluating whether this day is a weekday or not, and if we are on vacation or not. We could write down something like this to solve the problem: def sleep_in(weekday, vacation): if weekday == True and vacation == False: return False else return True Even though the solution above is correct, it is not a pythonic way of doing things. We could do this instead: def sleep_in(weekday, vacation): return not (weekday == True and vacation == False)","title":"Boolean Return Values"},{"location":"course/section_12/","text":"Recursion Recursion is a powerful programming technique where a function calls itself in order to solve smaller instances of the same problem. It is particularly useful for problems that can be broken down into simpler, repetitive tasks. Recursion occurs when a function calls itself. A recursive function must have a base case that stops the recursion and one or more recursive cases that break the problem into smaller instances and call the function itself. Basic Structure of a Recursive Function: def recursive_function(parameters): if base_case_condition: return base_case_value else: # Recursive case return recursive_function(modified_parameters) Example: Factorial Function The factorial of a non-negative integer n is the product of all positive integers less than or equal to n . It can be defined recursively as: factorial(0) = 1 (base case) factorial(n) = n * factorial(n-1) (recursive case) def factorial(n): if n == 0: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120 Practical Applications of Recursion Calculating Fibonacci Numbers: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. It can be defined recursively as: fibonacci(0) = 0 (base case) fibonacci(1) = 1 (base case) fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) (recursive case) def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(7)) # Output: 13 Sum of a List: You can use recursion to find the sum of a list of numbers. def sum_list(numbers): if len(numbers) == 0: return 0 else: return numbers[0] + sum_list(numbers[1:]) print(sum_list([1, 2, 3, 4, 5])) # Output: 15 Binary Search: Binary search is an efficient algorithm for finding an item in a sorted list. It works by repeatedly dividing the list in half and comparing the target value to the middle element. def binary_search(arr, target, low, high): if low > high: return -1 # Base case: target not found mid = (low + high) // 2 if arr[mid] == target: return mid # Base case: target found elif arr[mid] > target: return binary_search(arr, target, low, mid - 1) # Search left half else: return binary_search(arr, target, mid + 1, high) # Search right half numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 6 print(binary_search(numbers, target, 0, len(numbers) - 1)) # Output: 5 Towers of Hanoi: The Towers of Hanoi is a classic problem where you have three pegs and a number of disks of different sizes. The goal is to move all the disks from one peg to another, following these rules: Only one disk can be moved at a time. A disk can only be placed on top of a larger disk. def towers_of_hanoi(n, source, target, auxiliary): if n == 1: print(f\"Move disk 1 from {source} to {target}\") else: towers_of_hanoi(n - 1, source, auxiliary, target) print(f\"Move disk {n} from {source} to {target}\") towers_of_hanoi(n - 1, auxiliary, target, source) towers_of_hanoi(3, 'A', 'C', 'B') Output: Move disk 1 from A to C Move disk 2 from A to B Move disk 1 from C to B Move disk 3 from A to C Move disk 1 from B to A Move disk 2 from B to C Move disk 1 from A to C Advantages of Recursion Simplicity: Recursive solutions are often more straightforward and easier to understand than their iterative counterparts. Elegance: Recursive functions can solve complex problems with minimal code. Disadvantages of Recursion Performance: Recursive functions can be less efficient and use more memory than iterative solutions due to the overhead of multiple function calls. Stack Overflow: Deep recursion can lead to stack overflow errors if the recursion depth exceeds the maximum stack size. Tips for Using Recursion Identify the Base Case: Ensure your recursive function has a well-defined base case to prevent infinite recursion. Simplify the Problem: Break the problem into smaller subproblems that are easier to solve. Avoid Redundant Calculations: Use memoization or caching to store results of expensive recursive calls to improve performance.","title":"Recursion"},{"location":"course/section_12/#recursion","text":"Recursion is a powerful programming technique where a function calls itself in order to solve smaller instances of the same problem. It is particularly useful for problems that can be broken down into simpler, repetitive tasks. Recursion occurs when a function calls itself. A recursive function must have a base case that stops the recursion and one or more recursive cases that break the problem into smaller instances and call the function itself.","title":"Recursion"},{"location":"course/section_12/#basic-structure-of-a-recursive-function","text":"def recursive_function(parameters): if base_case_condition: return base_case_value else: # Recursive case return recursive_function(modified_parameters) Example: Factorial Function The factorial of a non-negative integer n is the product of all positive integers less than or equal to n . It can be defined recursively as: factorial(0) = 1 (base case) factorial(n) = n * factorial(n-1) (recursive case) def factorial(n): if n == 0: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120","title":"Basic Structure of a Recursive Function:"},{"location":"course/section_12/#practical-applications-of-recursion","text":"Calculating Fibonacci Numbers: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. It can be defined recursively as: fibonacci(0) = 0 (base case) fibonacci(1) = 1 (base case) fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) (recursive case) def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(7)) # Output: 13 Sum of a List: You can use recursion to find the sum of a list of numbers. def sum_list(numbers): if len(numbers) == 0: return 0 else: return numbers[0] + sum_list(numbers[1:]) print(sum_list([1, 2, 3, 4, 5])) # Output: 15 Binary Search: Binary search is an efficient algorithm for finding an item in a sorted list. It works by repeatedly dividing the list in half and comparing the target value to the middle element. def binary_search(arr, target, low, high): if low > high: return -1 # Base case: target not found mid = (low + high) // 2 if arr[mid] == target: return mid # Base case: target found elif arr[mid] > target: return binary_search(arr, target, low, mid - 1) # Search left half else: return binary_search(arr, target, mid + 1, high) # Search right half numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 6 print(binary_search(numbers, target, 0, len(numbers) - 1)) # Output: 5 Towers of Hanoi: The Towers of Hanoi is a classic problem where you have three pegs and a number of disks of different sizes. The goal is to move all the disks from one peg to another, following these rules: Only one disk can be moved at a time. A disk can only be placed on top of a larger disk. def towers_of_hanoi(n, source, target, auxiliary): if n == 1: print(f\"Move disk 1 from {source} to {target}\") else: towers_of_hanoi(n - 1, source, auxiliary, target) print(f\"Move disk {n} from {source} to {target}\") towers_of_hanoi(n - 1, auxiliary, target, source) towers_of_hanoi(3, 'A', 'C', 'B') Output: Move disk 1 from A to C Move disk 2 from A to B Move disk 1 from C to B Move disk 3 from A to C Move disk 1 from B to A Move disk 2 from B to C Move disk 1 from A to C","title":"Practical Applications of Recursion"},{"location":"course/section_12/#advantages-of-recursion","text":"Simplicity: Recursive solutions are often more straightforward and easier to understand than their iterative counterparts. Elegance: Recursive functions can solve complex problems with minimal code.","title":"Advantages of Recursion"},{"location":"course/section_12/#disadvantages-of-recursion","text":"Performance: Recursive functions can be less efficient and use more memory than iterative solutions due to the overhead of multiple function calls. Stack Overflow: Deep recursion can lead to stack overflow errors if the recursion depth exceeds the maximum stack size.","title":"Disadvantages of Recursion"},{"location":"course/section_12/#tips-for-using-recursion","text":"Identify the Base Case: Ensure your recursive function has a well-defined base case to prevent infinite recursion. Simplify the Problem: Break the problem into smaller subproblems that are easier to solve. Avoid Redundant Calculations: Use memoization or caching to store results of expensive recursive calls to improve performance.","title":"Tips for Using Recursion"},{"location":"course/section_13/","text":"Sequences Sequences are a fundamental concept in Python that represent ordered collections of items. They allow you to store multiple values in a single variable and perform a variety of operations on them. Python provides several built-in sequence types, including lists, tuples, strings, and ranges. Types of Sequences There are several types of sequences in Python. Here are some of them: Lists Lists are mutable sequences, meaning their elements can be changed after the list is created. Lists are defined using square brackets [] . # Creating a list fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple # Modifying elements fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry'] Tuples Tuples are immutable sequences, meaning their elements cannot be changed after the tuple is created. Tuples are defined using parentheses () . # Creating a tuple coordinates = (10.0, 20.0) # Accessing elements print(coordinates[0]) # Output: 10.0 # Tuples cannot be modified # coordinates[1] = 30.0 # This will raise a TypeError Strings Strings are immutable sequences of characters. Strings are defined using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . # Creating a string greeting = \"Hello, world!\" # Accessing characters print(greeting[0]) # Output: H # Strings cannot be modified # greeting[0] = \"h\" # This will raise a TypeError Ranges Ranges represent immutable sequences of numbers and are commonly used for looping a specific number of times in for loops. They are defined using the range() function. # Creating a range numbers = range(5) # Converting range to list to view elements print(list(numbers)) # Output: [0, 1, 2, 3, 4] # Using range in a for loop for i in range(5): print(i) # Output: 0, 1, 2, 3, 4 Common Sequence Operations Length You can use the len() function to get the number of elements in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(len(fruits)) # Output: 3 Concatenation You can concatenate sequences of the same type using the + operator. list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6] Repetition You can repeat sequences using the * operator. fruits = [\"apple\", \"banana\"] repeated_fruits = fruits * 3 print(repeated_fruits) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana'] Membership You can check if an item is in a sequence using the in operator. fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"orange\" in fruits) # Output: False Slicing You can extract a subset of a sequence using slicing. The syntax is sequence[start:stop:step] . # Creating a list numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # Slicing from index 2 to 5 print(numbers[2:6]) # Output: [2, 3, 4, 5] # Slicing with a step print(numbers[::2]) # Output: [0, 2, 4, 6, 8] # Reversing a sequence print(numbers[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] Sequence Functions and Methods Here are some of the most used functions and methods involving sequences: min() and max() You can use the min() and max() functions to find the smallest and largest elements in a sequence. numbers = [1, 2, 3, 4, 5] print(min(numbers)) # Output: 1 print(max(numbers)) # Output: 5 sum() You can use the sum() function to calculate the sum of elements in a sequence. numbers = [1, 2, 3, 4, 5] print(sum(numbers)) # Output: 15 index() You can use the index() method to find the first occurrence of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(fruits.index(\"banana\")) # Output: 1 count() You can use the count() method to count the number of occurrences of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] print(fruits.count(\"banana\")) # Output: 2","title":"Sequences"},{"location":"course/section_13/#sequences","text":"Sequences are a fundamental concept in Python that represent ordered collections of items. They allow you to store multiple values in a single variable and perform a variety of operations on them. Python provides several built-in sequence types, including lists, tuples, strings, and ranges. Types of Sequences There are several types of sequences in Python. Here are some of them:","title":"Sequences"},{"location":"course/section_13/#lists","text":"Lists are mutable sequences, meaning their elements can be changed after the list is created. Lists are defined using square brackets [] . # Creating a list fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple # Modifying elements fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry']","title":"Lists"},{"location":"course/section_13/#tuples","text":"Tuples are immutable sequences, meaning their elements cannot be changed after the tuple is created. Tuples are defined using parentheses () . # Creating a tuple coordinates = (10.0, 20.0) # Accessing elements print(coordinates[0]) # Output: 10.0 # Tuples cannot be modified # coordinates[1] = 30.0 # This will raise a TypeError","title":"Tuples"},{"location":"course/section_13/#strings","text":"Strings are immutable sequences of characters. Strings are defined using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . # Creating a string greeting = \"Hello, world!\" # Accessing characters print(greeting[0]) # Output: H # Strings cannot be modified # greeting[0] = \"h\" # This will raise a TypeError","title":"Strings"},{"location":"course/section_13/#ranges","text":"Ranges represent immutable sequences of numbers and are commonly used for looping a specific number of times in for loops. They are defined using the range() function. # Creating a range numbers = range(5) # Converting range to list to view elements print(list(numbers)) # Output: [0, 1, 2, 3, 4] # Using range in a for loop for i in range(5): print(i) # Output: 0, 1, 2, 3, 4","title":"Ranges"},{"location":"course/section_13/#common-sequence-operations","text":"","title":"Common Sequence Operations"},{"location":"course/section_13/#length","text":"You can use the len() function to get the number of elements in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(len(fruits)) # Output: 3","title":"Length"},{"location":"course/section_13/#concatenation","text":"You can concatenate sequences of the same type using the + operator. list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6]","title":"Concatenation"},{"location":"course/section_13/#repetition","text":"You can repeat sequences using the * operator. fruits = [\"apple\", \"banana\"] repeated_fruits = fruits * 3 print(repeated_fruits) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana']","title":"Repetition"},{"location":"course/section_13/#membership","text":"You can check if an item is in a sequence using the in operator. fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"orange\" in fruits) # Output: False","title":"Membership"},{"location":"course/section_13/#slicing","text":"You can extract a subset of a sequence using slicing. The syntax is sequence[start:stop:step] . # Creating a list numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # Slicing from index 2 to 5 print(numbers[2:6]) # Output: [2, 3, 4, 5] # Slicing with a step print(numbers[::2]) # Output: [0, 2, 4, 6, 8] # Reversing a sequence print(numbers[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]","title":"Slicing"},{"location":"course/section_13/#sequence-functions-and-methods","text":"Here are some of the most used functions and methods involving sequences:","title":"Sequence Functions and Methods"},{"location":"course/section_13/#min-and-max","text":"You can use the min() and max() functions to find the smallest and largest elements in a sequence. numbers = [1, 2, 3, 4, 5] print(min(numbers)) # Output: 1 print(max(numbers)) # Output: 5","title":"min() and max()"},{"location":"course/section_13/#sum","text":"You can use the sum() function to calculate the sum of elements in a sequence. numbers = [1, 2, 3, 4, 5] print(sum(numbers)) # Output: 15","title":"sum()"},{"location":"course/section_13/#index","text":"You can use the index() method to find the first occurrence of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(fruits.index(\"banana\")) # Output: 1","title":"index()"},{"location":"course/section_13/#count","text":"You can use the count() method to count the number of occurrences of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] print(fruits.count(\"banana\")) # Output: 2","title":"count()"},{"location":"course/section_14/","text":"String Manipulation Strings are sequences of characters, and Python provides a variety of methods and operations to manipulate strings. Understanding how to work with strings is essential for tasks like processing text data, building user interfaces, and more. Creating Strings Strings can be created using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . single_quote_string = 'Hello' double_quote_string = \"World\" triple_quote_string = '''This is a multi-line string.''' Accessing Characters in a String You can access individual characters in a string using indexing. Python uses zero-based indexing. greeting = \"Hello, World!\" # Accessing characters print(greeting[0]) # Output: H print(greeting[-1]) # Output: ! Slicing Strings Slicing allows you to extract a substring from a string. The syntax is string[start:stop:step] . # Creating a string greeting = \"Hello, World!\" # Slicing the string print(greeting[0:5]) # Output: Hello print(greeting[7:12]) # Output: World print(greeting[::2]) # Output: Hlo ol! String Methods Python provides many built-in methods to manipulate strings. Here are some commonly used string methods: Changing Case upper() : Converts all characters to uppercase. lower() : Converts all characters to lowercase. capitalize() : Capitalizes the first character of the string. message = \"hello, world!\" print(message.upper()) # Output: HELLO, WORLD! print(message.lower()) # Output: hello, world! print(message.capitalize()) # Output: Hello, world! Stripping Whitespace strip() : Removes leading and trailing whitespace. lstrip() : Removes leading whitespace. rstrip() : Removes trailing whitespace. message = \" Hello, World! \" print(message.strip()) # Output: Hello, World! print(message.lstrip()) # Output: Hello, World! print(message.rstrip()) # Output: Hello, World! Finding and Replacing find() : Returns the index of the first occurrence of a substring. replace() : Replaces all occurrences of a substring with another substring. message = \"Hello, World!\" print(message.find(\"World\")) # Output: 7 print(message.replace(\"World\", \"Python\")) # Output: Hello, Python! Splitting and Joining split() : Splits the string into a list of substrings based on a delimiter. join() : Joins a list of strings into a single string with a specified delimiter. message = \"Hello, World! How are you?\" words = message.split() print(words) # Output: ['Hello,', 'World!', 'How', 'are', 'you?'] joined_message = \" \".join(words) print(joined_message) # Output: Hello, World! How are you? String Formatting String formatting allows you to create strings with dynamic content. name = \"Alice\" age = 30 message = f\"My name is {name} and I am {age} years old.\" print(message) # Output: My name is Alice and I am 30 years old. Practical Applications Validating User Input: You can use string methods to validate and clean user input. user_input = \" Hello, Python! \" # Strip leading/trailing whitespace and convert to uppercase cleaned_input = user_input.strip().upper() print(cleaned_input) # Output: HELLO, PYTHON! Parsing CSV Data: You can use string splitting to parse CSV (Comma-Separated Values) data. csv_data = \"name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\" # Split into lines lines = csv_data.split(\"\\n\") # Process each line for line in lines: fields = line.split(\",\") print(fields) # Output: ['name', 'age', 'city'], ['Alice', '30', 'New York'], ['Bob', '25', 'Los Angeles'] Creating Slugs for URLs: You can use string manipulation to create URL-friendly slugs. title = \"Hello, World! Welcome to Python.\" # Convert to lowercase, replace spaces with hyphens, and remove punctuation slug = title.lower().replace(\" \", \"-\").replace(\"!\", \"\").replace(\",\", \"\").replace(\".\", \"\") print(slug) # Output: hello-world-welcome-to-python","title":"String Manipulation"},{"location":"course/section_14/#string-manipulation","text":"Strings are sequences of characters, and Python provides a variety of methods and operations to manipulate strings. Understanding how to work with strings is essential for tasks like processing text data, building user interfaces, and more.","title":"String Manipulation"},{"location":"course/section_14/#creating-strings","text":"Strings can be created using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . single_quote_string = 'Hello' double_quote_string = \"World\" triple_quote_string = '''This is a multi-line string.'''","title":"Creating Strings"},{"location":"course/section_14/#accessing-characters-in-a-string","text":"You can access individual characters in a string using indexing. Python uses zero-based indexing. greeting = \"Hello, World!\" # Accessing characters print(greeting[0]) # Output: H print(greeting[-1]) # Output: !","title":"Accessing Characters in a String"},{"location":"course/section_14/#slicing-strings","text":"Slicing allows you to extract a substring from a string. The syntax is string[start:stop:step] . # Creating a string greeting = \"Hello, World!\" # Slicing the string print(greeting[0:5]) # Output: Hello print(greeting[7:12]) # Output: World print(greeting[::2]) # Output: Hlo ol!","title":"Slicing Strings"},{"location":"course/section_14/#string-methods","text":"Python provides many built-in methods to manipulate strings. Here are some commonly used string methods:","title":"String Methods"},{"location":"course/section_14/#changing-case","text":"upper() : Converts all characters to uppercase. lower() : Converts all characters to lowercase. capitalize() : Capitalizes the first character of the string. message = \"hello, world!\" print(message.upper()) # Output: HELLO, WORLD! print(message.lower()) # Output: hello, world! print(message.capitalize()) # Output: Hello, world!","title":"Changing Case"},{"location":"course/section_14/#stripping-whitespace","text":"strip() : Removes leading and trailing whitespace. lstrip() : Removes leading whitespace. rstrip() : Removes trailing whitespace. message = \" Hello, World! \" print(message.strip()) # Output: Hello, World! print(message.lstrip()) # Output: Hello, World! print(message.rstrip()) # Output: Hello, World!","title":"Stripping Whitespace"},{"location":"course/section_14/#finding-and-replacing","text":"find() : Returns the index of the first occurrence of a substring. replace() : Replaces all occurrences of a substring with another substring. message = \"Hello, World!\" print(message.find(\"World\")) # Output: 7 print(message.replace(\"World\", \"Python\")) # Output: Hello, Python!","title":"Finding and Replacing"},{"location":"course/section_14/#splitting-and-joining","text":"split() : Splits the string into a list of substrings based on a delimiter. join() : Joins a list of strings into a single string with a specified delimiter. message = \"Hello, World! How are you?\" words = message.split() print(words) # Output: ['Hello,', 'World!', 'How', 'are', 'you?'] joined_message = \" \".join(words) print(joined_message) # Output: Hello, World! How are you?","title":"Splitting and Joining"},{"location":"course/section_14/#string-formatting","text":"String formatting allows you to create strings with dynamic content. name = \"Alice\" age = 30 message = f\"My name is {name} and I am {age} years old.\" print(message) # Output: My name is Alice and I am 30 years old.","title":"String Formatting"},{"location":"course/section_14/#practical-applications","text":"Validating User Input: You can use string methods to validate and clean user input. user_input = \" Hello, Python! \" # Strip leading/trailing whitespace and convert to uppercase cleaned_input = user_input.strip().upper() print(cleaned_input) # Output: HELLO, PYTHON! Parsing CSV Data: You can use string splitting to parse CSV (Comma-Separated Values) data. csv_data = \"name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\" # Split into lines lines = csv_data.split(\"\\n\") # Process each line for line in lines: fields = line.split(\",\") print(fields) # Output: ['name', 'age', 'city'], ['Alice', '30', 'New York'], ['Bob', '25', 'Los Angeles'] Creating Slugs for URLs: You can use string manipulation to create URL-friendly slugs. title = \"Hello, World! Welcome to Python.\" # Convert to lowercase, replace spaces with hyphens, and remove punctuation slug = title.lower().replace(\" \", \"-\").replace(\"!\", \"\").replace(\",\", \"\").replace(\".\", \"\") print(slug) # Output: hello-world-welcome-to-python","title":"Practical Applications"},{"location":"course/section_15/","text":"Exceptions and Exception Handling in Python Exceptions are errors that occur during the execution of a program. When an exception occurs, the normal flow of the program is interrupted, and Python raises an error message. Exception handling allows you to manage these errors gracefully and maintain the flow of your program. Understanding Exceptions An exception is an event that disrupts the normal execution of your program. Common exceptions include division by zero, file not found, and index out of range. Example: # Division by zero exception result = 10 / 0 # This will raise a ZeroDivisionError Common Exceptions: ZeroDivisionError : Raised when you divide by zero. IndexError : Raised when you access an invalid index in a list or other sequence. KeyError : Raised when you access a dictionary with a key that does not exist. ValueError : Raised when a function receives an argument of the correct type but inappropriate value. TypeError : Raised when an operation or function is applied to an object of inappropriate type. FileNotFoundError : Raised when an attempt to open a file that does not exist fails. Exception Handling You can handle exceptions using try and except blocks. This allows you to catch and handle errors gracefully without stopping the execution of your program. Basic Syntax: try: # Code that might raise an exception pass except ExceptionType: # Code to execute if an exception occurs pass try: result = 10 / 0 except ZeroDivisionError: print(\"Cannot divide by zero!\") Handling Multiple Exceptions You can handle multiple exceptions by specifying multiple except blocks. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\") Using else and finally The else block is executed if no exceptions are raised in the try block. The finally block is executed regardless of whether an exception is raised or not, and is often used for cleanup actions. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\") else: print(f\"The result is {result}\") finally: print(\"Execution complete.\") Raising Exceptions You can raise exceptions using the raise keyword. This is useful when you want to enforce certain conditions in your code. def check_age(age): if age < 0: raise ValueError(\"Age cannot be negative!\") return age try: age = check_age(-1) except ValueError as e: print(e) Creating Custom Exceptions You can create custom exceptions by defining a new class that inherits from the built-in Exception class. class CustomError(Exception): pass def test_custom_exception(): raise CustomError(\"This is a custom exception!\") try: test_custom_exception() except CustomError as e: print(e) Practical Applications File Handling with Exception Handling: Exception handling is often used when working with files to handle scenarios where a file might not exist or cannot be opened. try: with open(\"nonexistent_file.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"The file does not exist.\") Input Validation: Exception handling can be used to validate user input and handle invalid inputs gracefully. def get_integer_input(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"Invalid input! Please enter a valid integer.\") age = get_integer_input(\"Enter your age: \") print(f\"Your age is {age}.\")","title":"Exceptions"},{"location":"course/section_15/#exceptions-and-exception-handling-in-python","text":"Exceptions are errors that occur during the execution of a program. When an exception occurs, the normal flow of the program is interrupted, and Python raises an error message. Exception handling allows you to manage these errors gracefully and maintain the flow of your program.","title":"Exceptions and Exception Handling in Python"},{"location":"course/section_15/#understanding-exceptions","text":"An exception is an event that disrupts the normal execution of your program. Common exceptions include division by zero, file not found, and index out of range. Example: # Division by zero exception result = 10 / 0 # This will raise a ZeroDivisionError","title":"Understanding Exceptions"},{"location":"course/section_15/#common-exceptions","text":"ZeroDivisionError : Raised when you divide by zero. IndexError : Raised when you access an invalid index in a list or other sequence. KeyError : Raised when you access a dictionary with a key that does not exist. ValueError : Raised when a function receives an argument of the correct type but inappropriate value. TypeError : Raised when an operation or function is applied to an object of inappropriate type. FileNotFoundError : Raised when an attempt to open a file that does not exist fails.","title":"Common Exceptions:"},{"location":"course/section_15/#exception-handling","text":"You can handle exceptions using try and except blocks. This allows you to catch and handle errors gracefully without stopping the execution of your program. Basic Syntax: try: # Code that might raise an exception pass except ExceptionType: # Code to execute if an exception occurs pass try: result = 10 / 0 except ZeroDivisionError: print(\"Cannot divide by zero!\")","title":"Exception Handling"},{"location":"course/section_15/#handling-multiple-exceptions","text":"You can handle multiple exceptions by specifying multiple except blocks. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\")","title":"Handling Multiple Exceptions"},{"location":"course/section_15/#using-else-and-finally","text":"The else block is executed if no exceptions are raised in the try block. The finally block is executed regardless of whether an exception is raised or not, and is often used for cleanup actions. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\") else: print(f\"The result is {result}\") finally: print(\"Execution complete.\")","title":"Using else and finally"},{"location":"course/section_15/#raising-exceptions","text":"You can raise exceptions using the raise keyword. This is useful when you want to enforce certain conditions in your code. def check_age(age): if age < 0: raise ValueError(\"Age cannot be negative!\") return age try: age = check_age(-1) except ValueError as e: print(e)","title":"Raising Exceptions"},{"location":"course/section_15/#creating-custom-exceptions","text":"You can create custom exceptions by defining a new class that inherits from the built-in Exception class. class CustomError(Exception): pass def test_custom_exception(): raise CustomError(\"This is a custom exception!\") try: test_custom_exception() except CustomError as e: print(e)","title":"Creating Custom Exceptions"},{"location":"course/section_15/#practical-applications","text":"File Handling with Exception Handling: Exception handling is often used when working with files to handle scenarios where a file might not exist or cannot be opened. try: with open(\"nonexistent_file.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"The file does not exist.\") Input Validation: Exception handling can be used to validate user input and handle invalid inputs gracefully. def get_integer_input(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"Invalid input! Please enter a valid integer.\") age = get_integer_input(\"Enter your age: \") print(f\"Your age is {age}.\")","title":"Practical Applications"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Computer Programming I! This is an introductory course in program engineering and applications. This course introduces students to the fundamentals of computer programming. Throughout the semester, students will learn to design, code, and test their own programs while applying mathematical concepts. They will also be exposed to problem-solving techniques while approaching coding challenges, with the goal to prepare them for a more advanced programming course in the future. To achieve this objective, we will use the Python programming language, one of the most vastly used coding languages out there. However, with the concepts learned in this course, the student will be able to learn any other languages on their own, if they so desire. Course Objectives Students will be familiar with IDEs. Students will understand program development methodology and best practices. Students will understand and implement key programming concepts. Students will understand and implement control structures. Students will be aware of career opportunities in the Computer Programming/Software Engineering industry. This Is What This Course Is Not Students will NOT become hackers in this course. Students will NOT learn how to fix computers in this course. Students will NOT know how to create a web page for a company in this course. Students will NOT become expert programmers or geniuses in this course. For Parents This website was designed to offer you some insight about what your child is learning in class. It will also serve as some sort of calendar, so you know which assignments your child has to complete and when they have to complete it. I also want to make sure you understand that you can reach out to me whenever you want if you have any questions or concerns. I want to make sure your child has the best education possible, but you have to be involved for this to be more easily achievable. If we work together, we can ensure your child will have better chances to succeed in life. Your child will probably need to study at home to complete this course successfully. Please encourage them to do so.","title":"About"},{"location":"#welcome-to-computer-programming-i","text":"This is an introductory course in program engineering and applications. This course introduces students to the fundamentals of computer programming. Throughout the semester, students will learn to design, code, and test their own programs while applying mathematical concepts. They will also be exposed to problem-solving techniques while approaching coding challenges, with the goal to prepare them for a more advanced programming course in the future. To achieve this objective, we will use the Python programming language, one of the most vastly used coding languages out there. However, with the concepts learned in this course, the student will be able to learn any other languages on their own, if they so desire.","title":"Welcome to Computer Programming I!"},{"location":"#course-objectives","text":"Students will be familiar with IDEs. Students will understand program development methodology and best practices. Students will understand and implement key programming concepts. Students will understand and implement control structures. Students will be aware of career opportunities in the Computer Programming/Software Engineering industry.","title":"Course Objectives"},{"location":"#this-is-what-this-course-is-not","text":"Students will NOT become hackers in this course. Students will NOT learn how to fix computers in this course. Students will NOT know how to create a web page for a company in this course. Students will NOT become expert programmers or geniuses in this course.","title":"This Is What This Course Is Not"},{"location":"#for-parents","text":"This website was designed to offer you some insight about what your child is learning in class. It will also serve as some sort of calendar, so you know which assignments your child has to complete and when they have to complete it. I also want to make sure you understand that you can reach out to me whenever you want if you have any questions or concerns. I want to make sure your child has the best education possible, but you have to be involved for this to be more easily achievable. If we work together, we can ensure your child will have better chances to succeed in life. Your child will probably need to study at home to complete this course successfully. Please encourage them to do so.","title":"For Parents"},{"location":"course/","text":"Course Structure and Syllabus This page will contain some useful information regarding what is being taught in this course. Feel free to read this over and over again until you are satisfied. There are also links to other useful sources of information that can be used. At the end of the semester, students will have the opportunity to take a certification test to ensure that they've learned the content, gaining an industry-issued certificate to use, if they want to. Git and Github What is Git? Git is a powerful tool used by software developers to manage and keep track of changes in their code. Think of it as a sophisticated \"undo\" button for your projects, allowing you to revert to previous versions of your code, track changes over time, and collaborate with others without losing your work. Here are some key features of Git: Version Control: Git keeps a history of all changes made to your code, so you can see what was changed, who changed it, and when. Branching and Merging: You can create branches to work on new features or bug fixes without affecting the main codebase. Once your work is complete, you can merge it back into the main branch. Collaboration: Multiple people can work on the same project simultaneously without overwriting each other's work. What is GitHub? GitHub is an online platform that hosts Git repositories, making it easier for you to manage your projects and collaborate with others. It's like a social network for programmers, where you can share your code, contribute to others' projects, and showcase your work. Here are some things you can do with GitHub: Repository Hosting: Store your projects in repositories, which are like folders for your code. Collaboration Tools: Use pull requests to review and discuss changes before merging them into your project. Project Management: Organize your work with issues, milestones, and project boards. Community Engagement: Follow other developers, contribute to open-source projects, and build your professional network. How Git and GitHub Work Together Initialize a Repository: Start by creating a new repository on your computer using Git. This will track changes to your project files. Make Changes: Write code, make changes, and commit them to your local repository. A commit is like a snapshot of your project at a particular point in time. Push to GitHub: Once you have a series of commits, you can push them to GitHub, making your changes available online. Collaborate: Others can clone your repository, make changes, and submit pull requests. You can review these changes and merge them into your project. Some Basic Git Commands Here are some essential Git commands you'll use frequently: git init : Initializes a new Git repository. git clone [url] : Copies an existing repository from GitHub to your local machine. git status : Shows the status of changes in your working directory. git add [file] : Stages a file, preparing it for a commit. git commit -m \"message\" : Commits the staged changes with a descriptive message. git push : Uploads your commits to GitHub. git pull : Fetches and integrates changes from GitHub to your local repository. Getting Started with GitHub Sign Up: Create a free account on GitHub. Create a Repository: Click the \"New\" button on your GitHub dashboard to create a new repository. Clone the Repository: Use git clone [url] to copy the repository to your computer. Start Coding: Make changes to your project files, commit them, and push them to GitHub. By using Git and GitHub, you'll learn valuable skills for managing your code and collaborating with others. As we progress through the course, you'll become more comfortable with these tools and see how they fit into the larger world of software development. Class Assignment For this class assignment, we will work with GitHub's built in tutorial, available in our GitHub Classroom. Here's the link to the first assignment: First Assignment - Git and GitHub fundamentals DEADLINE: August 23, at midnight! Basic Types in Python Why Do We Use Programming? Programming allows us to perform operations on data to solve problems, automate tasks, and create applications. Imagine you have a list of students' grades and you want to find the average. Doing this manually is time-consuming and prone to errors. With programming, you can write a few lines of code to calculate the average quickly and accurately. The Need for Types When programming, it's important to understand the kind of data we're working with. Different types of data require different operations. For example, you can add two numbers together, but adding a number and a word doesn't make sense. This is where types come in. Types help the computer understand what kind of data it is dealing with so it can perform the correct operations. Types in Python Python, like many programming languages, has several built-in types to handle different kinds of data. Let's explore the most common types: Integers ( int ) Integers are whole numbers, both positive and negative. They do not have any decimal points. Examples: 5 -42 1000 Floating-Point Numbers ( float ) Floating-point numbers are numbers with decimal points. They can represent very large or very small numbers. Examples: 3.14 -0.001 100.0 Strings ( str ) Strings are sequences of characters, like words or sentences. They are enclosed in either single quotes ( ' ) or double quotes ( \" ). Examples: \"Hello, world!\" 'Python is fun!' \"12345\" # This is a string, not an integer Booleans ( bool ) Booleans represent one of two values: True or False . They are used to perform logical operations and control the flow of a program. Examples: True False Lists ( list ) Lists are ordered collections of items. You can store different types of data in a list, and lists can be changed after they are created. Examples: [1, 2, 3, 4, 5] [\"apple\", \"banana\", \"cherry\"] [True, False, True] Tuples ( tuple ) Tuples are similar to lists, but they are immutable, meaning they cannot be changed after they are created. They are useful for storing related pieces of data that should not be altered. Examples: (1, 2, 3) (\"red\", \"green\", \"blue\") (True, False, False) Dictionaries ( dict ) Dictionaries are collections of key-value pairs. Each key in a dictionary is unique and is used to store and retrieve values. Examples: {\"name\": \"Alice\", \"age\": 25, \"city\": \"New York\"} {\"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1964} The Concept of Values In programming, a value is the actual data stored in a variable or constant. The type of a value determines what operations can be performed on it. For example, you can add, subtract, multiply, and divide integer and floating-point values, but you can't perform these operations on strings. Examples of Values: Integer value: 42 Floating-point value: 3.14159 String value: \"Hello\" Boolean value: True Understanding types and values is fundamental to programming because it helps you write correct and efficient code. As you practice more, you'll become familiar with how to use different types to solve problems and create applications. Practice Time! Try the following exercises to get comfortable with different types in Python: Create variables of each type (integer, float, string, boolean, list, tuple, dictionary) and print them out. Perform basic operations with these types (e.g., addition for numbers, concatenation for strings, adding items to a list). Write a small program that uses a dictionary to store information about a person (name, age, city) and prints out a sentence using this information. Code Structure Writing code is like writing a set of instructions for the computer to follow. How we organize these instructions is called code structure. Good code structure makes your programs easier to read, understand, and maintain. Code Structure Here are some key elements of code structure: Indentation In Python, indentation (spaces at the beginning of a line) is used to define the structure of your code. Code blocks (like the body of a loop or a function) are indented to show that they belong to a specific structure. Example: if True: print(\"This is indented\") Comments Comments are notes you can add to your code to explain what it does. They are ignored by the computer and are meant to help humans understand the code. Example: # This is a comment print(\"Hello, world!\") # This prints a message to the screen Code Blocks A code block is a group of statements that are executed together. In Python, code blocks are defined by their indentation. Examples of Code Blocks: If Statement if condition: # This is a code block print(\"Condition is true\") For Loop for i in range(5): # This is a code block print(i) Function Definition def greet(name): # This is a code block print(f\"Hello, {name}!\") Expressions An expression is a combination of values, variables, and operators that the computer evaluates to produce another value. Expressions can be as simple as a single value or as complex as a series of operations. Examples of Expressions: 5 + 3 (This evaluates to 8 ) len(\"Hello\") (This evaluates to 5 ) x * y - z (This evaluates to the result of multiplying x and y and then subtracting z ) Expressions are used in assignments, function calls, and other operations to produce values that your program can work with. Symbols (Intro to Variables and Constants) Symbols are how we give names to values (objects). Symbols must begin with an underscore or letter. Symbols can contain any number of underscores, letters and numbers. this_is_a_symbol this_is_2 _AsIsThis 1butThisIsNot nor-is-this Symbols (names) don\u2019t have a type; values do. This is why Python is \u201cDynamic\u201d. Variables A variable is a symbol that holds a value. Think of it as a container that stores data that can be used and manipulated in your program. Variables make your code more flexible and easier to understand. To create a variable, you simply give it a name and assign it a value using the equals sign ( = ). Example: age = 16 name = \"John\" is_student = True Constants A constant is similar to a variable, but its value is meant to remain the same throughout the program. By convention, constants are written in all uppercase letters. Example: PI = 3.14159 MAX_STUDENTS = 30 Constants are useful for values that do not change, such as mathematical constants or configuration settings. Putting It All Together Here's a small program that demonstrates code structure, code blocks, expressions, and symbols: # Define a constant PI = 3.14159 # Define a function to calculate the area of a circle def calculate_area(radius): # This is a code block inside the function area = PI * (radius ** 2) return area # Main part of the program radius = 5 print(f\"The area of a circle with radius {radius} is {calculate_area(radius)}\") In this example: We define a constant PI . We define a function calculate_area with a code block inside. We use an expression PI * (radius ** 2) to calculate the area. We create a variable radius and use it in a function call. Practice Time! Try the following exercises to get comfortable with code structure, code blocks, expressions, and symbols: Write a program that defines a few variables and prints their values. Create a function that takes two numbers as arguments and returns their sum. Test your function with different values. Write a program that uses a loop to print the numbers from 1 to 10. Add comments to explain what each part of the code does. Understanding these fundamental concepts will help you build more complex and powerful programs. Happy coding! Expressions and Variables Expressions What is an Expression? An expression in Python is a combination of values, variables, and operators that, when evaluated, produces a new value. Expressions are fundamental building blocks in programming and are used to perform calculations, manipulate data, and control the flow of a program. Types of Expressions Arithmetic Expressions : These involve mathematical operations like addition, subtraction, multiplication, and division. Examples: 5 + 3 # Addition, evaluates to 8 10 - 2 # Subtraction, evaluates to 8 4 * 2 # Multiplication, evaluates to 8 16 / 2 # Division, evaluates to 8.0 String Expressions : These involve operations on strings, such as concatenation. Examples: \"Hello, \" + \"world!\" # Concatenation, evaluates to \"Hello, world!\" Boolean Expressions : These involve logical operations and comparisons, resulting in a Boolean value ( True or False ). Examples: 5 > 3 # Greater than, evaluates to True 10 == 2 * 5 # Equality, evaluates to True 4 != 2 + 2 # Inequality, evaluates to False Function Calls : Expressions can also involve calling functions, which may return values. Examples: len(\"Hello\") # Function call, evaluates to 5 Evaluating Expressions When Python encounters an expression, it evaluates it to produce a value. This value can then be used in further calculations, assigned to variables, or passed to functions. Example: result = 5 + 3 # The expression 5 + 3 evaluates to 8, which is assigned to the variable result print(result) # This prints 8 Variables What is a Variable? A variable is a named storage location in memory that holds a value. Variables allow you to store data and refer to it later in your program. You can think of a variable as a container for data. Declaring and Initializing Variables To declare a variable, you simply assign a value to it using the equals sign ( = ). This process is called initialization. Examples: age = 16 # The variable age is assigned the value 16 name = \"Alice\" # The variable name is assigned the value \"Alice\" is_student = True # The variable is_student is assigned the value True Using Variables Once you have declared a variable, you can use it in expressions, pass it to functions, and modify its value. Examples: # Using variables in expressions x = 10 y = 5 sum = x + y # sum is assigned the value 15 # Passing variables to functions def greet(person): print(f\"Hello, {person}!\") greet(name) # This prints \"Hello, Alice!\" # Modifying variables count = 0 count = count + 1 # count is now 1 count += 2 # count is now 3 Variable Naming Rules When naming variables in Python, follow these rules: Use letters (a-z, A-Z), digits (0-9), and underscores (_). Do not start a variable name with a digit. Variable names are case-sensitive ( age and Age are different variables). Choose meaningful names that describe the data they hold. Valid examples: student_name = \"John\" total_score = 95 is_enrolled = True Invalid examples: 2nd_place = \"Bob\" # Starts with a digit total-score = 95 # Uses a hyphen instead of an underscore class = \"Math\" # Uses a reserved keyword Constants A constant is similar to a variable but is meant to remain unchanged throughout the program. By convention, constants are written in all uppercase letters. Examples: PI = 3.14159 MAX_STUDENTS = 30 Importance of Variables Variables are essential because they allow you to: Store and reuse values. Make your code more readable and maintainable. Write flexible and dynamic programs. Practice Time! Try the following exercises to get comfortable with expressions and variables: Declare variables of different types (integer, float, string, boolean) and print their values. Write expressions that involve these variables and print the results. Create a function that takes a variable as an argument and performs an operation using that variable. Modify the values of your variables and observe how the output of your program changes. By mastering expressions and variables, you'll be well on your way to writing effective and powerful Python programs. Happy coding! Assignments in Python Assignments in Python are the process or tool used to store values in variables. They allow us to keep track of data and use it throughout our programs. In this section, we'll explore different types of assignments. In-Place Assignments In-place assignments allow you to update the value of a variable using its current value. This is done with special operators that combine assignment with an arithmetic operation. Examples of In-Place Assignments Addition Assignment ( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction Assignment ( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication Assignment ( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division Assignment ( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0 In-place assignments make your code more concise and can be easier to read. Multiple Assignments Python allows you to assign values to multiple variables simultaneously. This can make your code more efficient and easier to read. Examples of Multiple Assignments Assigning Multiple Variables at Once x, y, z = 1, 2, 3 print(x) # Output: 1 print(y) # Output: 2 print(z) # Output: 3 Swapping Values Using Multiple Assignments a, b = 5, 10 a, b = b, a # Swaps the values of a and b print(a) # Output: 10 print(b) # Output: 5 Unpacking Values from a List or Tuple coordinates = (4, 5) x, y = coordinates print(x) # Output: 4 print(y) # Output: 5 Multiple assignments can be particularly useful when you need to initialize several variables at once or swap their values. Two-Variable Swap Swapping the values of two variables is a common task in programming. Python makes this easy with a simple syntax. Swapping Two Variables Traditional Swap Using a Temporary Variable x = 1 y = 2 temp = x x = y y = temp print(x) # Output: 2 print(y) # Output: 1 Pythonic Swap Using Multiple Assignments a = 3 b = 4 a, b = b, a # Swaps the values of a and b print(a) # Output: 4 print(b) # Output: 3 The Pythonic way of swapping values is more concise and avoids the need for a temporary variable, making your code cleaner. Practice Time! Try the following exercises to get comfortable with assignments: In-Place Assignments: Start with a variable n = 10 . Use in-place assignments to add 5 to n , subtract 3 from n , multiply n by 2, and divide n by 4. Print the value of n after each operation. Multiple Assignments: Assign the values 10 , 20 , and 30 to the variables x , y , and z in a single line. Print the values of x , y , and z . Swap the values of x and z using multiple assignments. Print the values of x , y , and z again. Two-Variable Swap: Assign the values 15 and 25 to the variables a and b . Swap their values using both the traditional method and the Pythonic method. Print the values of a and b after each swap. By mastering these assignment techniques, you'll be able to write more efficient and readable Python code. Happy coding! Operators Operators are special symbols in Python that perform operations on values and variables. They are the building blocks of expressions, allowing you to perform calculations, comparisons, and logical operations. In this section, we'll explore different types of operators and how to use them. Arithmetic Operators Arithmetic operators are used to perform basic mathematical operations like addition, subtraction, multiplication, and division. Examples of Arithmetic Operators Addition ( + ) x = 5 y = 3 result = x + y # Adds x and y print(result) # Output: 8 Subtraction ( - ) x = 10 y = 4 result = x - y # Subtracts y from x print(result) # Output: 6 Multiplication ( * ) x = 7 y = 6 result = x * y # Multiplies x by y print(result) # Output: 42 Division ( / ) x = 20 y = 4 result = x / y # Divides x by y print(result) # Output: 5.0 Floor Division ( // ) x = 20 y = 3 result = x // y # Divides x by y and returns the integer part print(result) # Output: 6 Modulus ( % ) x = 10 y = 3 result = x % y # Returns the remainder of x divided by y print(result) # Output: 1 **Exponentiation ( ** )** x = 2 y = 3 result = x ** y # Raises x to the power of y print(result) # Output: 8 Assignment Operators Assignment operators are used to assign values to variables. We've already seen the basic assignment operator ( = ), but there are also compound assignment operators that combine an arithmetic operation with assignment. Examples of Assignment Operators Basic Assignment ( = ) x = 10 # Assigns the value 10 to x print(x) # Output: 10 Addition Assignment ( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction Assignment ( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication Assignment ( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division Assignment ( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0 Modulus Assignment ( %= ) b = 10 b %= 3 # Equivalent to b = b % 3 print(b) # Output: 1 **Exponentiation Assignment ( **= )** c = 2 c **= 3 # Equivalent to c = c ** 3 print(c) # Output: 8 Floor Division Assignment ( //= ) d = 20 d //= 3 # Equivalent to d = d // 3 print(d) # Output: 6 Comparison Operators Comparison operators are used to compare two values and return a Boolean result ( True or False ). Examples of Comparison Operators Equal to ( == ) x = 5 y = 5 result = (x == y) # Checks if x is equal to y print(result) # Output: True Not equal to ( != ) x = 5 y = 3 result = (x != y) # Checks if x is not equal to y print(result) # Output: True Greater than ( > ) x = 7 y = 4 result = (x > y) # Checks if x is greater than y print(result) # Output: True Less than ( < ) x = 2 y = 8 result = (x < y) # Checks if x is less than y print(result) # Output: True Greater than or equal to ( >= ) x = 6 y = 6 result = (x >= y) # Checks if x is greater than or equal to y print(result) # Output: True Less than or equal to ( <= ) x = 3 y = 5 result = (x <= y) # Checks if x is less than or equal to y print(result) # Output: True Logical Operators Logical operators are used to combine multiple Boolean expressions. Examples of Logical Operators AND ( and ) x = True y = False result = x and y # Checks if both x and y are True print(result) # Output: False OR ( or ) x = True y = False result = x or y # Checks if either x or y is True print(result) # Output: True NOT ( not ) x = True result = not x # Inverts the value of x print(result) # Output: False Identity Operators Identity operators are used to compare the memory locations of two objects. Examples of Identity Operators is x = [1, 2, 3] y = x z = [1, 2, 3] print(x is y) # Output: True, because y is the same object as x print(x is z) # Output: False, because z is a different object with the same contents is not a = 10 b = 20 print(a is not b) # Output: True, because a and b are not the same object Membership Operators Membership operators are used to test if a sequence contains a certain value. Examples of Membership Operators in fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True, because \"banana\" is in the list not in fruits = [\"apple\", \"banana\", \"cherry\"] print(\"orange\" not in fruits) # Output: True, because \"orange\" is not in the list Bitwise Operators Bitwise operators are used to perform operations on binary numbers. Examples of Bitwise Operators AND ( & ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x & y) # Output: 1 (0001 in binary) OR ( | ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x | y) # Output: 7 (0111 in binary) XOR ( ^ ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x ^ y) # Output: 6 (0110 in binary) NOT ( ~ ) x = 5 # 0101 in binary print(~x) # Output: -6 (inverts the bits, giving 1010 in binary, which is -6 in two's complement form) Left Shift ( << ) x = 5 # 0101 in binary print(x << 1) # Output: 10 (1010 in binary, shifts bits left by 1 position) Right Shift ( >> ) x = 5 # 0101 in binary print(x >> 1) # Output: 2 (0010 in binary, shifts bits right by 1 position) Operator Precedence Operator precedence determines the order in which operators are evaluated in expressions. Operators with higher precedence are evaluated before operators with lower precedence. Examples of Operator Precedence Arithmetic Operators x = 5 + 2 * 3 # Multiplication has higher precedence than addition print(x) # Output: 11 (2 * 3 is evaluated first, then 5 + 6) Using Parentheses to Change Precedence x = (5 + 2) * 3 # Parentheses change the order of evaluation print(x) # Output: 21 (5 + 2 is evaluated first, then 7 * 3) Combination of Different Operators x = 5 + 2 * 3 > 10 - 2 print(x) # Output: True (2 * 3 is evaluated first, then 5 + 6, then 10 - 2, finally 11 > 8) Here's a table summarizing the operator precedence in Python, from highest to lowest: Precedence Level Operators 1 (highest) () 2 ** 3 +x , -x , ~x 4 * , / , // , % 5 + , - 6 << , >> 7 & 8 ^ 9 binary or 10 in , not in , is , is not , < , <= , > , >= , != , == 11 not x 12 and 13 (lowest) or Practice Time! Try the following exercises to get comfortable with operators: Arithmetic Operators: Perform addition, subtraction, multiplication, division, floor division, modulus, and exponentiation operations with different values and print the results. Comparison Operators: Compare two values using each of the comparison operators and print the results. Logical Operators: Combine multiple Boolean expressions using and , or , and not operators and print the results. Identity and Membership Operators: Use is , is not , in , and not in with different values and collections and print the results. Bitwise Operators: Perform bitwise AND, OR, XOR, NOT, left shift, and right shift operations and print the results. Operator Precedence: Write expressions using multiple operators and experiment with parentheses to change the order of evaluation. Print the results to see how operator precedence affects the outcome. Understanding and mastering operators will allow you to perform a wide range of operations in your Python programs, making your code more powerful and flexible. Happy coding! Functions Functions are one of the most important building blocks in Python. They allow you to group code into reusable blocks, making your programs more modular, readable, and maintainable. What is a Function? A function is a block of code that performs a specific task. Functions help you to avoid repeating code by allowing you to define it once and reuse it as needed. Functions can take inputs, perform operations, and return outputs. Defining a Function To define a function in Python, use the def keyword followed by the function name and parentheses () which may include parameters. Example: def greet(name): print(f\"Hello, {name}!\") Calling a Function To call a function, simply use its name followed by parentheses, including any arguments required by the function. Example: greet(\"Alice\") # Output: Hello, Alice! Parameters and Arguments Parameters are variables defined in the function signature. Arguments are the values you pass to the function when you call it. Example: def add(a, b): return a + b result = add(3, 4) # Arguments 3 and 4 are passed to parameters a and b print(result) # Output: 7 Return Statement The return statement is used to send a result back from the function to the caller. Once return is executed, the function terminates. Example: def square(x): return x * x result = square(5) print(result) # Output: 25 Call Stack The call stack is a mechanism that keeps track of function calls. When a function is called, a frame is added to the stack. When the function returns, the frame is removed. The call stack helps manage the order in which functions are executed and their respective scopes. Example: def func1(): print(\"Start func1\") func2() print(\"End func1\") def func2(): print(\"Start func2\") func3() print(\"End func2\") def func3(): print(\"Start func3\") print(\"End func3\") func1() Output: Start func1 Start func2 Start func3 End func3 End func2 End func1 In this example, func1 calls func2 , and func2 calls func3 . The call stack manages these calls and ensures each function returns in the correct order. Traceback A traceback is a report that Python generates when an error occurs in your program. It shows the call stack at the point where the error happened, helping you to diagnose and fix issues. Example: def divide(x, y): return x / y result = divide(10, 0) Output: Traceback (most recent call last): File \"example.py\", line 5, in <module> result = divide(10, 0) File \"example.py\", line 2, in divide return x / y ZeroDivisionError: division by zero The traceback shows that the error occurred in the divide function because of a division by zero. Function Scope and Lifetime Variables defined inside a function are local to that function. They exist only during the function's execution and are not accessible outside. Example: def func(): x = 10 # x is local to func print(x) func() print(x) # Error: x is not defined outside func Recursive Functions A function that calls itself is known as a recursive function. Recursion can be used to solve problems that can be broken down into simpler, repetitive tasks. Example: def factorial(n): if n == 1: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120 Practice Time! Try the following exercises to get comfortable with functions: Basic Functions: Write a function multiply that takes two arguments and returns their product. Write a function is_even that returns True if a number is even and False otherwise. Using Return Statements: Write a function max_of_three that takes three numbers as arguments and returns the maximum of the three. Write a function sum_of_squares that returns the sum of the squares of two numbers. Understanding the Call Stack: Write a series of nested function calls to see the call stack in action. Use print statements to show the flow of execution. Handling Tracebacks: Intentionally create a function that will generate an error (e.g., division by zero) and observe the traceback. Modify the function to handle the error gracefully. Recursion: Write a recursive function fibonacci that returns the nth Fibonacci number. Write a recursive function to calculate the greatest common divisor (GCD) of two numbers. Understanding functions, return statements, the call stack, and tracebacks will give you a strong foundation in writing modular and error-resistant Python code. Happy coding! Conditionals Conditionals allow you to execute different code based on certain conditions. They are fundamental to controlling the flow of your programs, making decisions, and performing actions based on those decisions. If Statements The if statement is used to test a condition. If the condition is True , the code block inside the if statement is executed. Example: age = 18 if age >= 18: print(\"You are an adult.\") Else Statements The else statement is used in conjunction with the if statement. It defines a block of code that will be executed if the if condition is False . Example: age = 16 if age >= 18: print(\"You are an adult.\") else: print(\"You are a minor.\") Elif Statements The elif (short for \"else if\") statement allows you to check multiple conditions. If the first if condition is False , the program checks the elif conditions in order. If one of the elif conditions is True , its block of code is executed. Example: score = 85 if score >= 90: print(\"Grade: A\") elif score >= 80: print(\"Grade: B\") elif score >= 70: print(\"Grade: C\") elif score >= 60: print(\"Grade: D\") else: print(\"Grade: F\") Nested If Statements You can nest if , elif , and else statements inside other if , elif , and else statements to create more complex conditions. Example: num = 15 if num % 2 == 0: print(\"The number is even.\") else: print(\"The number is odd.\") if num % 3 == 0: print(\"The number is also divisible by 3.\") Conditional Expressions (Ternary Operator) A conditional expression, also known as a ternary operator, allows you to write a simple if-else statement in one line. Example: age = 18 status = \"adult\" if age >= 18 else \"minor\" print(status) # Output: adult Combining Conditions You can combine multiple conditions using logical operators and , or , and not to create more complex conditional statements. Examples: Using and : num = 10 if num > 5 and num < 15: print(\"The number is between 5 and 15.\") Using or : day = \"Saturday\" if day == \"Saturday\" or day == \"Sunday\": print(\"It's the weekend!\") Using not : is_raining = False if not is_raining: print(\"It's not raining, you can go outside.\") Practice Time! Try the following exercises to get comfortable with conditionals: Basic If-Else: Write a program that checks if a number is positive, negative, or zero and prints the result. Grading System: Modify the grading example to include a condition for \"A+\" grade if the score is 95 or higher. Nested Conditionals: Write a program that checks if a year is a leap year. A leap year is divisible by 4 but not by 100, except if it is also divisible by 400. Ternary Operator: Use a conditional expression to set a variable parity to \"even\" if a number is even and \"odd\" if it is odd. Combining Conditions: Write a program that checks if a person can vote. A person can vote if they are at least 18 years old and a citizen. Understanding and using conditionals will enable you to create programs that can make decisions based on different inputs and scenarios, making your code more dynamic and interactive. Happy coding! Lists Lists are one of the most versatile and commonly used data structures in Python. They allow you to store collections of items in a single variable, making it easy to organize and manipulate data. Creating Lists A list is created by placing all the items (elements) inside square brackets [] , separated by commas. Examples: # A list of integers numbers = [1, 2, 3, 4, 5] # A list of strings fruits = [\"apple\", \"banana\", \"cherry\"] # A mixed list mixed = [1, \"hello\", 3.14, True] Accessing List Elements You can access individual elements in a list using their index. Python uses zero-based indexing, meaning the first element has an index of 0. Examples: fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple print(fruits[2]) # Output: cherry # Accessing elements from the end print(fruits[-1]) # Output: cherry print(fruits[-2]) # Output: banana Modifying Lists Lists are mutable, meaning you can change their elements after they have been created. Examples: fruits = [\"apple\", \"banana\", \"cherry\"] # Changing an element fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry'] # Adding elements fruits.append(\"date\") print(fruits) # Output: ['apple', 'blueberry', 'cherry', 'date'] # Inserting elements fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'blueberry', 'cherry', 'date'] # Removing elements fruits.remove(\"blueberry\") print(fruits) # Output: ['apple', 'banana', 'cherry', 'date'] List Operations Python provides many built-in methods and operations that you can use to manipulate lists. Examples: Length of a List: numbers = [1, 2, 3, 4, 5] print(len(numbers)) # Output: 5 Concatenation: list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6] Repetition: fruits = [\"apple\", \"banana\"] print(fruits * 3) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana'] Slicing: numbers = [1, 2, 3, 4, 5] print(numbers[1:4]) # Output: [2, 3, 4] print(numbers[:3]) # Output: [1, 2, 3] print(numbers[2:]) # Output: [3, 4, 5] Checking Membership: fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"date\" not in fruits) # Output: True List Comprehensions List comprehensions provide a concise way to create lists. They can be used to generate new lists by applying an expression to each element in an existing list. Example: # Creating a list of squares squares = [x ** 2 for x in range(1, 6)] print(squares) # Output: [1, 4, 9, 16, 25] Common List Methods append() : Adds an element to the end of the list. fruits = [\"apple\", \"banana\"] fruits.append(\"cherry\") print(fruits) # Output: ['apple', 'banana', 'cherry'] insert() : Inserts an element at a specified position. fruits = [\"apple\", \"cherry\"] fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'cherry'] remove() : Removes the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] fruits.remove(\"banana\") print(fruits) # Output: ['apple', 'cherry'] pop() : Removes and returns the element at a specified position (default is the last element). fruits = [\"apple\", \"banana\", \"cherry\"] fruit = fruits.pop() print(fruit) # Output: cherry print(fruits) # Output: ['apple', 'banana'] index() : Returns the index of the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] index = fruits.index(\"banana\") print(index) # Output: 1 count() : Returns the number of times a specified element appears in the list. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] count = fruits.count(\"banana\") print(count) # Output: 2 sort() : Sorts the list in ascending order. numbers = [4, 2, 3, 1, 5] numbers.sort() print(numbers) # Output: [1, 2, 3, 4, 5] reverse() : Reverses the order of the list. numbers = [1, 2, 3, 4, 5] numbers.reverse() print(numbers) # Output: [5, 4, 3, 2, 1] Practice Time! Try the following exercises to get comfortable with lists: Basic List Operations: Create a list of your favorite movies. Add a new movie to the list, remove one movie, and print the updated list. List Slicing: Given a list of numbers, create a new list containing only the first half of the original list. List Comprehensions: Create a list of the first 10 even numbers using a list comprehension. Using List Methods: Write a program that asks the user to input their top 5 favorite foods and then prints the list in alphabetical order. Combining Lists: Create two lists of different subjects you are studying this semester. Combine them into one list and print the combined list. By mastering lists, you'll be able to store and manipulate collections of data efficiently, making your Python programs more powerful and flexible. Happy coding! Loops Loops allow you to execute a block of code multiple times, making your programs more efficient and reducing the need for repetitive code. In Python, there are two main types of loops: for loops and while loops. For Loops A for loop is used to iterate over a sequence (such as a list, tuple, string, or range) and execute a block of code for each item in the sequence. Syntax: for variable in sequence: # Code to execute for each item Examples: Iterating Over a List: fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(fruit) Using the range() Function: for i in range(5): print(i) Iterating Over a String: for letter in \"hello\": print(letter) While Loops A while loop continues to execute as long as a specified condition is True . It is useful when the number of iterations is not known beforehand. Syntax: while condition: # Code to execute while the condition is True Examples: Basic while Loop: count = 0 while count < 5: print(count) count += 1 Using a while Loop for User Input: user_input = \"\" while user_input != \"exit\": user_input = input(\"Type 'exit' to stop: \") Nested Loops You can nest loops inside other loops to perform more complex iterations. Each iteration of the outer loop triggers the complete execution of the inner loop. Example: for i in range(3): for j in range(2): print(f\"i = {i}, j = {j}\") Loop Control Statements Python provides several statements to control the execution of loops: break : Terminates the loop prematurely. for i in range(10): if i == 5: break print(i) continue : Skips the current iteration and proceeds to the next iteration. for i in range(5): if i == 3: continue print(i) else : Executes a block of code after the loop finishes, unless the loop is terminated by a break statement. for i in range(5): print(i) else: print(\"Loop finished successfully\") Using Loops with Lists Loops are often used to iterate over lists and perform operations on each element. Examples: Calculating the Sum of a List: numbers = [1, 2, 3, 4, 5] total = 0 for number in numbers: total += number print(\"Total:\", total) Finding the Maximum Element in a List: numbers = [3, 7, 2, 5, 9] max_number = numbers[0] for number in numbers: if number > max_number: max_number = number print(\"Maximum number:\", max_number) Using a while Loop to Create a List: even_numbers = [] num = 2 while num <= 10: even_numbers.append(num) num += 2 print(\"Even numbers:\", even_numbers) Practice Time! Try the following exercises to get comfortable with loops: Basic for Loop: Write a for loop that prints the numbers from 1 to 10. Basic while Loop: Write a while loop that prints the numbers from 10 to 1. Nested Loops: Write a nested loop to print a multiplication table from 1 to 5. Loop Control Statements: Write a loop that prints numbers from 1 to 20, but skips multiples of 3 using the continue statement. Write a loop that prints numbers from 1 to 10, but stops the loop if the number is 7 using the break statement. Working with Lists: Write a program that calculates the average of a list of numbers using a for loop. Write a program that finds the smallest number in a list using a for loop. By mastering loops, you'll be able to write more efficient and powerful programs that can handle repetitive tasks with ease. Happy coding! Boolean Expressions Boolean expressions are expressions that evaluate to either True or False . They are fundamental to decision-making in programming, allowing you to control the flow of your code based on conditions. Boolean Values Python has two boolean values: True and False . These values are the result of boolean expressions and are used in conditional statements, loops, and other control structures. Examples: is_raining = True is_sunny = False Comparison Operators Comparison operators are used to compare two values and produce a boolean result ( True or False ). Examples of Comparison Operators: Equal to ( == ) x = 5 y = 5 print(x == y) # Output: True Not equal to ( != ) x = 5 y = 3 print(x != y) # Output: True Greater than ( > ) x = 7 y = 4 print(x > y) # Output: True Less than ( < ) x = 2 y = 8 print(x < y) # Output: True Greater than or equal to ( >= ) x = 6 y = 6 print(x >= y) # Output: True Less than or equal to ( <= ) x = 3 y = 5 print(x <= y) # Output: True Logical Operators Logical operators are used to combine multiple boolean expressions and return a boolean result. Examples of Logical Operators: AND ( and ) x = True y = False print(x and y) # Output: False OR ( or ) x = True y = False print(x or y) # Output: True NOT ( not ) x = True print(not x) # Output: False Pythonic Booleans Python has a concept of \"truthy\" and \"falsy\" values, where certain values are implicitly converted to True or False in a boolean context. Truthy Values: Non-zero numbers Non-empty strings Non-empty collections (lists, tuples, dictionaries, etc.) Falsy Values: None False Zero ( 0 , 0.0 , 0j ) Empty strings ( \"\" ) Empty collections ( [] , () , {} ) Examples: if 0: print(\"This is truthy.\") else: print(\"This is falsy.\") # Output: This is falsy. if \"hello\": print(\"This is truthy.\") # Output: This is truthy. else: print(\"This is falsy.\") Shortcutting Shortcutting (short-circuit evaluation) is a feature in Python where logical operators and and or stop evaluating as soon as the result is determined. This can make your code more efficient by avoiding unnecessary computations. Basic Examples: AND Shortcutting: In an AND operation, if any operand is False , the whole expression is False , and evaluation stops immediately. a = False b = True result = a and b print(result) # Output: False Here, a is False , so b is not evaluated because the result is already determined to be False . OR Shortcutting: In an OR operation, if any operand is True , the whole expression is True , and evaluation stops immediately. a = True b = False result = a or b print(result) # Output: True Here, a is True , so b is not evaluated because the result is already determined to be True . Practical Applications: Avoiding Errors with Shortcutting: You can use shortcutting to prevent errors by ensuring that certain conditions are met before performing operations. user_input = None # Avoiding attribute error by checking for None if user_input and user_input.strip() != \"\": print(f\"User input: {user_input.strip()}\") else: print(\"No valid input provided.\") In this example, user_input.strip() is only called if user_input is not None , preventing a potential AttributeError . Conditional Execution: Use shortcutting to conditionally execute functions or expressions only when necessary. def expensive_operation(): print(\"Expensive operation executed.\") return True condition = False # Expensive operation will not execute because condition is False result = condition and expensive_operation() print(result) # Output: False In this example, expensive_operation is not called because condition is False . Setting Default Values: Use shortcutting with the or operator to provide default values. primary_value = None secondary_value = \"Secondary\" default_value = \"Default\" # Uses secondary_value because primary_value is None result = primary_value or secondary_value or default_value print(result) # Output: Secondary Here, secondary_value is used because primary_value is None . Input Validation: Use shortcutting to validate multiple conditions in user input. password = \"mypassword123\" # Check if password is valid: at least 8 characters, contains a digit, and contains a letter is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if all conditions are true. If the first condition fails, the subsequent checks are not performed. Short-Circuiting with Function Calls: Use shortcutting to decide whether to call a function based on certain conditions. def greet(): print(\"Hello!\") name = \"Alice\" # Greet only if name is not empty name and greet() # Output: Hello! In this example, greet() is called only if name is not an empty string. Summary: Shortcutting allows you to optimize your code by stopping evaluation as soon as the result is determined. This feature is useful for preventing errors, improving performance, and making your code more concise. By understanding how shortcutting works, you can effectively use it to handle conditional execution, validate inputs, and manage complex logical flows in your programs. Chaining You can chain multiple comparisons together in a single expression. Example: x = 5 print(1 < x < 10) # Output: True print(10 < x < 20) # Output: False The idea here is that the first value that defines the result in a chained expression is returned: a or b or c or d a and b and c and d Applications: Finding the First Truthy Value (OR Chaining): In an OR chain, the first truthy value is returned, or the last value if none are truthy. a = None b = \"\" c = 0 d = \"Python\" result = a or b or c or d print(result) # Output: Python In this example, d is the first truthy value, so it is returned. Ensuring All Conditions are True (AND Chaining): In an AND chain, the first falsy value is returned, or the last value if all are truthy. a = True b = 5 > 3 c = 10 == 10 d = 0 # This is falsy result = a and b and c and d print(result) # Output: 0 In this example, d is the first falsy value, so it is returned. Default Values with OR Chaining: You can use OR chaining to provide default values if previous values are falsy. username = input(\"Enter your username: \") or \"Guest\" print(f\"Welcome, {username}!\") If the user inputs an empty string, \"Guest\" is used as the default value. Checking Multiple Conditions with AND Chaining: You can use AND chaining to ensure multiple conditions are met. age = 25 has_permission = True is_member = True if age > 18 and has_permission and is_member: print(\"Access granted.\") else: print(\"Access denied.\") In this example, access is granted only if all conditions are true. Conditional Assignment: You can use chaining to assign values based on multiple conditions. score = 85 grade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'D' if score >= 60 else 'F' print(f\"Your grade is: {grade}\") This example assigns a grade based on the score using chained comparisons. Validating User Input: Chaining can be used to validate multiple conditions in user input. password = \"mypassword123\" is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if it is at least 8 characters long, contains at least one digit, and contains at least one letter. Summary: Chaining allows you to combine multiple comparisons and logical operations into a single, concise expression. This technique is useful for simplifying code and making it more readable. By understanding how chaining works, you can effectively use it to handle default values, validate conditions, and manage complex logical flows in your programs. Boolean Return Values Functions can return boolean values, making them useful for complex conditions. Imagine we are trying to write down a function that checks if we're allowed to sleep in or not in a certain day, evaluating whether this day is a weekday or not, and if we are on vacation or not. We could write down something like this to solve the problem: def sleep_in(weekday, vacation): if weekday == True and vacation == False: return False else return True Even though the solution above is correct, it is not a pythonic way of doing things. We could do this instead: def sleep_in(weekday, vacation): return not (weekday == True and vacation == False) Practice Time! Try the following exercises to get comfortable with boolean expressions: Comparison Operators: Write a program that compares two numbers and prints whether the first is greater than, less than, or equal to the second. Logical Operators: Write a program that checks if a number is within a specified range (e.g., between 10 and 20) using logical operators. Boolean Expressions in Conditionals: Write a program that asks the user for their age and prints whether they are a child (under 13), a teenager (13-19), or an adult (20 and above). Pythonic Booleans: Write a program that takes a list and prints True if the list is not empty and False if it is empty. Shortcutting: Write a program that uses logical operators with shortcutting to determine if certain conditions are met. Chaining: Write a program that takes three numbers and prints the largest one using chained comparison operators. Boolean Return Values: Write a function that checks if a number is both positive and even, returning True or False . Understanding boolean expressions is crucial for controlling the flow of your programs and making decisions based on conditions. Mastering these concepts will make you a more effective and efficient programmer. Happy coding! Recursion Recursion is a powerful programming technique where a function calls itself in order to solve smaller instances of the same problem. It is particularly useful for problems that can be broken down into simpler, repetitive tasks. What is Recursion? Recursion occurs when a function calls itself. A recursive function must have a base case that stops the recursion and one or more recursive cases that break the problem into smaller instances and call the function itself. Basic Structure of a Recursive Function: def recursive_function(parameters): if base_case_condition: return base_case_value else: # Recursive case return recursive_function(modified_parameters) Example: Factorial Function The factorial of a non-negative integer n is the product of all positive integers less than or equal to n . It can be defined recursively as: factorial(0) = 1 (base case) factorial(n) = n * factorial(n-1) (recursive case) def factorial(n): if n == 0: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120 Practical Applications of Recursion Calculating Fibonacci Numbers: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. It can be defined recursively as: fibonacci(0) = 0 (base case) fibonacci(1) = 1 (base case) fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) (recursive case) def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(7)) # Output: 13 Sum of a List: You can use recursion to find the sum of a list of numbers. def sum_list(numbers): if len(numbers) == 0: return 0 else: return numbers[0] + sum_list(numbers[1:]) print(sum_list([1, 2, 3, 4, 5])) # Output: 15 Binary Search: Binary search is an efficient algorithm for finding an item in a sorted list. It works by repeatedly dividing the list in half and comparing the target value to the middle element. def binary_search(arr, target, low, high): if low > high: return -1 # Base case: target not found mid = (low + high) // 2 if arr[mid] == target: return mid # Base case: target found elif arr[mid] > target: return binary_search(arr, target, low, mid - 1) # Search left half else: return binary_search(arr, target, mid + 1, high) # Search right half numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 6 print(binary_search(numbers, target, 0, len(numbers) - 1)) # Output: 5 Towers of Hanoi: The Towers of Hanoi is a classic problem where you have three pegs and a number of disks of different sizes. The goal is to move all the disks from one peg to another, following these rules: Only one disk can be moved at a time. A disk can only be placed on top of a larger disk. def towers_of_hanoi(n, source, target, auxiliary): if n == 1: print(f\"Move disk 1 from {source} to {target}\") else: towers_of_hanoi(n - 1, source, auxiliary, target) print(f\"Move disk {n} from {source} to {target}\") towers_of_hanoi(n - 1, auxiliary, target, source) towers_of_hanoi(3, 'A', 'C', 'B') Output: Move disk 1 from A to C Move disk 2 from A to B Move disk 1 from C to B Move disk 3 from A to C Move disk 1 from B to A Move disk 2 from B to C Move disk 1 from A to C Advantages of Recursion Simplicity: Recursive solutions are often more straightforward and easier to understand than their iterative counterparts. Elegance: Recursive functions can solve complex problems with minimal code. Disadvantages of Recursion Performance: Recursive functions can be less efficient and use more memory than iterative solutions due to the overhead of multiple function calls. Stack Overflow: Deep recursion can lead to stack overflow errors if the recursion depth exceeds the maximum stack size. Tips for Using Recursion Identify the Base Case: Ensure your recursive function has a well-defined base case to prevent infinite recursion. Simplify the Problem: Break the problem into smaller subproblems that are easier to solve. Avoid Redundant Calculations: Use memoization or caching to store results of expensive recursive calls to improve performance. Practice Time! Try the following exercises to get comfortable with recursion: Recursive Factorial: Write a recursive function to calculate the factorial of a number. Recursive Fibonacci: Write a recursive function to calculate the nth Fibonacci number. Sum of a List: Write a recursive function to find the sum of a list of numbers. Binary Search: Implement a recursive binary search function to find an element in a sorted list. Towers of Hanoi: Solve the Towers of Hanoi problem for 4 disks. Understanding recursion is crucial for solving many types of problems efficiently. By mastering recursive thinking, you'll be able to tackle complex tasks with elegant and powerful solutions. Happy coding! Sequences Sequences are a fundamental concept in Python that represent ordered collections of items. They allow you to store multiple values in a single variable and perform a variety of operations on them. Python provides several built-in sequence types, including lists, tuples, strings, and ranges. Types of Sequences There are several types of sequences in Python. Here are some of them: Lists Lists are mutable sequences, meaning their elements can be changed after the list is created. Lists are defined using square brackets [] . # Creating a list fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple # Modifying elements fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry'] Tuples Tuples are immutable sequences, meaning their elements cannot be changed after the tuple is created. Tuples are defined using parentheses () . # Creating a tuple coordinates = (10.0, 20.0) # Accessing elements print(coordinates[0]) # Output: 10.0 # Tuples cannot be modified # coordinates[1] = 30.0 # This will raise a TypeError Strings Strings are immutable sequences of characters. Strings are defined using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . # Creating a string greeting = \"Hello, world!\" # Accessing characters print(greeting[0]) # Output: H # Strings cannot be modified # greeting[0] = \"h\" # This will raise a TypeError Ranges Ranges represent immutable sequences of numbers and are commonly used for looping a specific number of times in for loops. They are defined using the range() function. # Creating a range numbers = range(5) # Converting range to list to view elements print(list(numbers)) # Output: [0, 1, 2, 3, 4] # Using range in a for loop for i in range(5): print(i) # Output: 0, 1, 2, 3, 4 Common Sequence Operations Length You can use the len() function to get the number of elements in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(len(fruits)) # Output: 3 Concatenation You can concatenate sequences of the same type using the + operator. list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6] Repetition You can repeat sequences using the * operator. fruits = [\"apple\", \"banana\"] repeated_fruits = fruits * 3 print(repeated_fruits) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana'] Membership You can check if an item is in a sequence using the in operator. fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"orange\" in fruits) # Output: False Slicing You can extract a subset of a sequence using slicing. The syntax is sequence[start:stop:step] . # Creating a list numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # Slicing from index 2 to 5 print(numbers[2:6]) # Output: [2, 3, 4, 5] # Slicing with a step print(numbers[::2]) # Output: [0, 2, 4, 6, 8] # Reversing a sequence print(numbers[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] Sequence Functions and Methods Here are some of the most used functions and methods involving sequences: min() and max() You can use the min() and max() functions to find the smallest and largest elements in a sequence. numbers = [1, 2, 3, 4, 5] print(min(numbers)) # Output: 1 print(max(numbers)) # Output: 5 sum() You can use the sum() function to calculate the sum of elements in a sequence. numbers = [1, 2, 3, 4, 5] print(sum(numbers)) # Output: 15 index() You can use the index() method to find the first occurrence of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(fruits.index(\"banana\")) # Output: 1 count() You can use the count() method to count the number of occurrences of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] print(fruits.count(\"banana\")) # Output: 2 Practice Time! Try the following exercises to get comfortable with sequences: List Operations: Create a list of your favorite movies. Add a new movie to the list, remove one movie, and print the updated list. Tuple Operations: Create a tuple with five elements. Access and print the second and fourth elements. String Operations: Create a string and use slicing to print the first five characters, the last three characters, and the string in reverse. Range Operations: Use the range() function to create a list of even numbers from 0 to 20 and print the list. Sequence Functions: Write a program to find the minimum, maximum, and sum of a list of numbers. Membership and Indexing: Create a list of fruits. Check if \"apple\" is in the list, find the index of \"banana\", and count how many times \"cherry\" appears in the list. Understanding sequences and how to manipulate them is crucial for working with data in Python. By mastering these concepts, you'll be able to store, access, and process collections of data efficiently. Happy coding! String Manipulation Strings are sequences of characters, and Python provides a variety of methods and operations to manipulate strings. Understanding how to work with strings is essential for tasks like processing text data, building user interfaces, and more. Creating Strings Strings can be created using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . single_quote_string = 'Hello' double_quote_string = \"World\" triple_quote_string = '''This is a multi-line string.''' Accessing Characters in a String You can access individual characters in a string using indexing. Python uses zero-based indexing. greeting = \"Hello, World!\" # Accessing characters print(greeting[0]) # Output: H print(greeting[-1]) # Output: ! Slicing Strings Slicing allows you to extract a substring from a string. The syntax is string[start:stop:step] . # Creating a string greeting = \"Hello, World!\" # Slicing the string print(greeting[0:5]) # Output: Hello print(greeting[7:12]) # Output: World print(greeting[::2]) # Output: Hlo ol! String Methods Python provides many built-in methods to manipulate strings. Here are some commonly used string methods: Changing Case upper() : Converts all characters to uppercase. lower() : Converts all characters to lowercase. capitalize() : Capitalizes the first character of the string. message = \"hello, world!\" print(message.upper()) # Output: HELLO, WORLD! print(message.lower()) # Output: hello, world! print(message.capitalize()) # Output: Hello, world! Stripping Whitespace strip() : Removes leading and trailing whitespace. lstrip() : Removes leading whitespace. rstrip() : Removes trailing whitespace. message = \" Hello, World! \" print(message.strip()) # Output: Hello, World! print(message.lstrip()) # Output: Hello, World! print(message.rstrip()) # Output: Hello, World! Finding and Replacing find() : Returns the index of the first occurrence of a substring. replace() : Replaces all occurrences of a substring with another substring. message = \"Hello, World!\" print(message.find(\"World\")) # Output: 7 print(message.replace(\"World\", \"Python\")) # Output: Hello, Python! Splitting and Joining split() : Splits the string into a list of substrings based on a delimiter. join() : Joins a list of strings into a single string with a specified delimiter. message = \"Hello, World! How are you?\" words = message.split() print(words) # Output: ['Hello,', 'World!', 'How', 'are', 'you?'] joined_message = \" \".join(words) print(joined_message) # Output: Hello, World! How are you? String Formatting String formatting allows you to create strings with dynamic content. name = \"Alice\" age = 30 message = f\"My name is {name} and I am {age} years old.\" print(message) # Output: My name is Alice and I am 30 years old. Practical Applications Validating User Input: You can use string methods to validate and clean user input. user_input = \" Hello, Python! \" # Strip leading/trailing whitespace and convert to uppercase cleaned_input = user_input.strip().upper() print(cleaned_input) # Output: HELLO, PYTHON! Parsing CSV Data: You can use string splitting to parse CSV (Comma-Separated Values) data. csv_data = \"name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\" # Split into lines lines = csv_data.split(\"\\n\") # Process each line for line in lines: fields = line.split(\",\") print(fields) # Output: ['name', 'age', 'city'], ['Alice', '30', 'New York'], ['Bob', '25', 'Los Angeles'] Creating Slugs for URLs: You can use string manipulation to create URL-friendly slugs. title = \"Hello, World! Welcome to Python.\" # Convert to lowercase, replace spaces with hyphens, and remove punctuation slug = title.lower().replace(\" \", \"-\").replace(\"!\", \"\").replace(\",\", \"\").replace(\".\", \"\") print(slug) # Output: hello-world-welcome-to-python Practice Time! Try the following exercises to get comfortable with string manipulation: Basic String Operations: Create a string and use slicing to print the first five characters, the last three characters, and the string in reverse. String Methods: Write a program that takes a string input from the user, converts it to uppercase, and removes any leading or trailing whitespace. Finding and Replacing: Write a program that replaces all occurrences of \"Python\" with \"JavaScript\" in a given string. Splitting and Joining: Write a program that splits a sentence into words, then joins the words with a hyphen ( - ) and prints the result. String Formatting: Write a program that takes a user's name and age as input and prints a formatted message using both the format() method and f-strings. By mastering string manipulation, you'll be able to handle text data efficiently and create dynamic and interactive programs. Happy coding! Exceptions and Exception Handling in Python Exceptions are errors that occur during the execution of a program. When an exception occurs, the normal flow of the program is interrupted, and Python raises an error message. Exception handling allows you to manage these errors gracefully and maintain the flow of your program. Understanding Exceptions An exception is an event that disrupts the normal execution of your program. Common exceptions include division by zero, file not found, and index out of range. Example of an Exception: # Division by zero exception result = 10 / 0 # This will raise a ZeroDivisionError Common Exceptions: ZeroDivisionError : Raised when you divide by zero. IndexError : Raised when you access an invalid index in a list or other sequence. KeyError : Raised when you access a dictionary with a key that does not exist. ValueError : Raised when a function receives an argument of the correct type but inappropriate value. TypeError : Raised when an operation or function is applied to an object of inappropriate type. FileNotFoundError : Raised when an attempt to open a file that does not exist fails. Exception Handling You can handle exceptions using try and except blocks. This allows you to catch and handle errors gracefully without stopping the execution of your program. Basic Syntax: try: # Code that might raise an exception pass except ExceptionType: # Code to execute if an exception occurs pass try: result = 10 / 0 except ZeroDivisionError: print(\"Cannot divide by zero!\") Handling Multiple Exceptions You can handle multiple exceptions by specifying multiple except blocks. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\") Using else and finally The else block is executed if no exceptions are raised in the try block. The finally block is executed regardless of whether an exception is raised or not, and is often used for cleanup actions. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\") else: print(f\"The result is {result}\") finally: print(\"Execution complete.\") Raising Exceptions You can raise exceptions using the raise keyword. This is useful when you want to enforce certain conditions in your code. def check_age(age): if age < 0: raise ValueError(\"Age cannot be negative!\") return age try: age = check_age(-1) except ValueError as e: print(e) Creating Custom Exceptions You can create custom exceptions by defining a new class that inherits from the built-in Exception class. class CustomError(Exception): pass def test_custom_exception(): raise CustomError(\"This is a custom exception!\") try: test_custom_exception() except CustomError as e: print(e) Practical Applications File Handling with Exception Handling: Exception handling is often used when working with files to handle scenarios where a file might not exist or cannot be opened. try: with open(\"nonexistent_file.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"The file does not exist.\") Input Validation: Exception handling can be used to validate user input and handle invalid inputs gracefully. def get_integer_input(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"Invalid input! Please enter a valid integer.\") age = get_integer_input(\"Enter your age: \") print(f\"Your age is {age}.\") Practice Time! Try the following exercises to get comfortable with exception handling: Basic Exception Handling: Write a program that asks the user for two numbers and divides the first by the second. Handle division by zero and invalid input exceptions. Handling Multiple Exceptions: Write a program that opens a file and reads its contents. Handle file not found and permission denied exceptions. Using else and finally : Write a program that calculates the square root of a number entered by the user. Use else to print the result if no exception occurs and finally to print a completion message. Raising Exceptions: Write a function that checks if a number is within a specified range. Raise a custom exception if the number is out of range and handle this exception in your main program. Creating Custom Exceptions: Create a custom exception called InvalidEmailError and write a function that validates an email address. Raise the custom exception if the email is invalid and handle it in your main program. By mastering exception handling, you'll be able to write more robust and reliable programs that can gracefully handle unexpected errors and conditions. Happy coding!","title":"Course Structure"},{"location":"course/#course-structure-and-syllabus","text":"This page will contain some useful information regarding what is being taught in this course. Feel free to read this over and over again until you are satisfied. There are also links to other useful sources of information that can be used. At the end of the semester, students will have the opportunity to take a certification test to ensure that they've learned the content, gaining an industry-issued certificate to use, if they want to.","title":"Course Structure and Syllabus"},{"location":"course/#git-and-github","text":"","title":"Git and Github"},{"location":"course/#what-is-git","text":"Git is a powerful tool used by software developers to manage and keep track of changes in their code. Think of it as a sophisticated \"undo\" button for your projects, allowing you to revert to previous versions of your code, track changes over time, and collaborate with others without losing your work. Here are some key features of Git: Version Control: Git keeps a history of all changes made to your code, so you can see what was changed, who changed it, and when. Branching and Merging: You can create branches to work on new features or bug fixes without affecting the main codebase. Once your work is complete, you can merge it back into the main branch. Collaboration: Multiple people can work on the same project simultaneously without overwriting each other's work.","title":"What is Git?"},{"location":"course/#what-is-github","text":"GitHub is an online platform that hosts Git repositories, making it easier for you to manage your projects and collaborate with others. It's like a social network for programmers, where you can share your code, contribute to others' projects, and showcase your work. Here are some things you can do with GitHub: Repository Hosting: Store your projects in repositories, which are like folders for your code. Collaboration Tools: Use pull requests to review and discuss changes before merging them into your project. Project Management: Organize your work with issues, milestones, and project boards. Community Engagement: Follow other developers, contribute to open-source projects, and build your professional network.","title":"What is GitHub?"},{"location":"course/#how-git-and-github-work-together","text":"Initialize a Repository: Start by creating a new repository on your computer using Git. This will track changes to your project files. Make Changes: Write code, make changes, and commit them to your local repository. A commit is like a snapshot of your project at a particular point in time. Push to GitHub: Once you have a series of commits, you can push them to GitHub, making your changes available online. Collaborate: Others can clone your repository, make changes, and submit pull requests. You can review these changes and merge them into your project.","title":"How Git and GitHub Work Together"},{"location":"course/#some-basic-git-commands","text":"Here are some essential Git commands you'll use frequently: git init : Initializes a new Git repository. git clone [url] : Copies an existing repository from GitHub to your local machine. git status : Shows the status of changes in your working directory. git add [file] : Stages a file, preparing it for a commit. git commit -m \"message\" : Commits the staged changes with a descriptive message. git push : Uploads your commits to GitHub. git pull : Fetches and integrates changes from GitHub to your local repository.","title":"Some Basic Git Commands"},{"location":"course/#getting-started-with-github","text":"Sign Up: Create a free account on GitHub. Create a Repository: Click the \"New\" button on your GitHub dashboard to create a new repository. Clone the Repository: Use git clone [url] to copy the repository to your computer. Start Coding: Make changes to your project files, commit them, and push them to GitHub. By using Git and GitHub, you'll learn valuable skills for managing your code and collaborating with others. As we progress through the course, you'll become more comfortable with these tools and see how they fit into the larger world of software development.","title":"Getting Started with GitHub"},{"location":"course/#class-assignment","text":"For this class assignment, we will work with GitHub's built in tutorial, available in our GitHub Classroom. Here's the link to the first assignment: First Assignment - Git and GitHub fundamentals DEADLINE: August 23, at midnight!","title":"Class Assignment"},{"location":"course/#basic-types-in-python","text":"","title":"Basic Types in Python"},{"location":"course/#why-do-we-use-programming","text":"Programming allows us to perform operations on data to solve problems, automate tasks, and create applications. Imagine you have a list of students' grades and you want to find the average. Doing this manually is time-consuming and prone to errors. With programming, you can write a few lines of code to calculate the average quickly and accurately.","title":"Why Do We Use Programming?"},{"location":"course/#the-need-for-types","text":"When programming, it's important to understand the kind of data we're working with. Different types of data require different operations. For example, you can add two numbers together, but adding a number and a word doesn't make sense. This is where types come in. Types help the computer understand what kind of data it is dealing with so it can perform the correct operations.","title":"The Need for Types"},{"location":"course/#types-in-python","text":"Python, like many programming languages, has several built-in types to handle different kinds of data. Let's explore the most common types:","title":"Types in Python"},{"location":"course/#integers-int","text":"Integers are whole numbers, both positive and negative. They do not have any decimal points. Examples: 5 -42 1000","title":"Integers (int)"},{"location":"course/#floating-point-numbers-float","text":"Floating-point numbers are numbers with decimal points. They can represent very large or very small numbers. Examples: 3.14 -0.001 100.0","title":"Floating-Point Numbers (float)"},{"location":"course/#strings-str","text":"Strings are sequences of characters, like words or sentences. They are enclosed in either single quotes ( ' ) or double quotes ( \" ). Examples: \"Hello, world!\" 'Python is fun!' \"12345\" # This is a string, not an integer","title":"Strings (str)"},{"location":"course/#booleans-bool","text":"Booleans represent one of two values: True or False . They are used to perform logical operations and control the flow of a program. Examples: True False","title":"Booleans (bool)"},{"location":"course/#lists-list","text":"Lists are ordered collections of items. You can store different types of data in a list, and lists can be changed after they are created. Examples: [1, 2, 3, 4, 5] [\"apple\", \"banana\", \"cherry\"] [True, False, True]","title":"Lists (list)"},{"location":"course/#tuples-tuple","text":"Tuples are similar to lists, but they are immutable, meaning they cannot be changed after they are created. They are useful for storing related pieces of data that should not be altered. Examples: (1, 2, 3) (\"red\", \"green\", \"blue\") (True, False, False)","title":"Tuples (tuple)"},{"location":"course/#dictionaries-dict","text":"Dictionaries are collections of key-value pairs. Each key in a dictionary is unique and is used to store and retrieve values. Examples: {\"name\": \"Alice\", \"age\": 25, \"city\": \"New York\"} {\"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1964}","title":"Dictionaries (dict)"},{"location":"course/#the-concept-of-values","text":"In programming, a value is the actual data stored in a variable or constant. The type of a value determines what operations can be performed on it. For example, you can add, subtract, multiply, and divide integer and floating-point values, but you can't perform these operations on strings.","title":"The Concept of Values"},{"location":"course/#examples-of-values","text":"Integer value: 42 Floating-point value: 3.14159 String value: \"Hello\" Boolean value: True Understanding types and values is fundamental to programming because it helps you write correct and efficient code. As you practice more, you'll become familiar with how to use different types to solve problems and create applications.","title":"Examples of Values:"},{"location":"course/#practice-time","text":"Try the following exercises to get comfortable with different types in Python: Create variables of each type (integer, float, string, boolean, list, tuple, dictionary) and print them out. Perform basic operations with these types (e.g., addition for numbers, concatenation for strings, adding items to a list). Write a small program that uses a dictionary to store information about a person (name, age, city) and prints out a sentence using this information.","title":"Practice Time!"},{"location":"course/#code-structure","text":"Writing code is like writing a set of instructions for the computer to follow. How we organize these instructions is called code structure. Good code structure makes your programs easier to read, understand, and maintain.","title":"Code Structure"},{"location":"course/#code-structure_1","text":"Here are some key elements of code structure:","title":"Code Structure"},{"location":"course/#indentation","text":"In Python, indentation (spaces at the beginning of a line) is used to define the structure of your code. Code blocks (like the body of a loop or a function) are indented to show that they belong to a specific structure. Example: if True: print(\"This is indented\")","title":"Indentation"},{"location":"course/#comments","text":"Comments are notes you can add to your code to explain what it does. They are ignored by the computer and are meant to help humans understand the code. Example: # This is a comment print(\"Hello, world!\") # This prints a message to the screen","title":"Comments"},{"location":"course/#code-blocks","text":"A code block is a group of statements that are executed together. In Python, code blocks are defined by their indentation.","title":"Code Blocks"},{"location":"course/#examples-of-code-blocks","text":"","title":"Examples of Code Blocks:"},{"location":"course/#if-statement","text":"if condition: # This is a code block print(\"Condition is true\")","title":"If Statement"},{"location":"course/#for-loop","text":"for i in range(5): # This is a code block print(i)","title":"For Loop"},{"location":"course/#function-definition","text":"def greet(name): # This is a code block print(f\"Hello, {name}!\")","title":"Function Definition"},{"location":"course/#expressions","text":"An expression is a combination of values, variables, and operators that the computer evaluates to produce another value. Expressions can be as simple as a single value or as complex as a series of operations.","title":"Expressions"},{"location":"course/#examples-of-expressions","text":"5 + 3 (This evaluates to 8 ) len(\"Hello\") (This evaluates to 5 ) x * y - z (This evaluates to the result of multiplying x and y and then subtracting z ) Expressions are used in assignments, function calls, and other operations to produce values that your program can work with.","title":"Examples of Expressions:"},{"location":"course/#symbols-intro-to-variables-and-constants","text":"Symbols are how we give names to values (objects). Symbols must begin with an underscore or letter. Symbols can contain any number of underscores, letters and numbers. this_is_a_symbol this_is_2 _AsIsThis 1butThisIsNot nor-is-this Symbols (names) don\u2019t have a type; values do. This is why Python is \u201cDynamic\u201d.","title":"Symbols (Intro to Variables and Constants)"},{"location":"course/#variables","text":"A variable is a symbol that holds a value. Think of it as a container that stores data that can be used and manipulated in your program. Variables make your code more flexible and easier to understand. To create a variable, you simply give it a name and assign it a value using the equals sign ( = ). Example: age = 16 name = \"John\" is_student = True","title":"Variables"},{"location":"course/#constants","text":"A constant is similar to a variable, but its value is meant to remain the same throughout the program. By convention, constants are written in all uppercase letters. Example: PI = 3.14159 MAX_STUDENTS = 30 Constants are useful for values that do not change, such as mathematical constants or configuration settings.","title":"Constants"},{"location":"course/#putting-it-all-together","text":"Here's a small program that demonstrates code structure, code blocks, expressions, and symbols: # Define a constant PI = 3.14159 # Define a function to calculate the area of a circle def calculate_area(radius): # This is a code block inside the function area = PI * (radius ** 2) return area # Main part of the program radius = 5 print(f\"The area of a circle with radius {radius} is {calculate_area(radius)}\") In this example: We define a constant PI . We define a function calculate_area with a code block inside. We use an expression PI * (radius ** 2) to calculate the area. We create a variable radius and use it in a function call.","title":"Putting It All Together"},{"location":"course/#practice-time_1","text":"Try the following exercises to get comfortable with code structure, code blocks, expressions, and symbols: Write a program that defines a few variables and prints their values. Create a function that takes two numbers as arguments and returns their sum. Test your function with different values. Write a program that uses a loop to print the numbers from 1 to 10. Add comments to explain what each part of the code does. Understanding these fundamental concepts will help you build more complex and powerful programs. Happy coding!","title":"Practice Time!"},{"location":"course/#expressions-and-variables","text":"","title":"Expressions and Variables"},{"location":"course/#expressions_1","text":"","title":"Expressions"},{"location":"course/#what-is-an-expression","text":"An expression in Python is a combination of values, variables, and operators that, when evaluated, produces a new value. Expressions are fundamental building blocks in programming and are used to perform calculations, manipulate data, and control the flow of a program.","title":"What is an Expression?"},{"location":"course/#types-of-expressions","text":"Arithmetic Expressions : These involve mathematical operations like addition, subtraction, multiplication, and division. Examples: 5 + 3 # Addition, evaluates to 8 10 - 2 # Subtraction, evaluates to 8 4 * 2 # Multiplication, evaluates to 8 16 / 2 # Division, evaluates to 8.0 String Expressions : These involve operations on strings, such as concatenation. Examples: \"Hello, \" + \"world!\" # Concatenation, evaluates to \"Hello, world!\" Boolean Expressions : These involve logical operations and comparisons, resulting in a Boolean value ( True or False ). Examples: 5 > 3 # Greater than, evaluates to True 10 == 2 * 5 # Equality, evaluates to True 4 != 2 + 2 # Inequality, evaluates to False Function Calls : Expressions can also involve calling functions, which may return values. Examples: len(\"Hello\") # Function call, evaluates to 5","title":"Types of Expressions"},{"location":"course/#evaluating-expressions","text":"When Python encounters an expression, it evaluates it to produce a value. This value can then be used in further calculations, assigned to variables, or passed to functions. Example: result = 5 + 3 # The expression 5 + 3 evaluates to 8, which is assigned to the variable result print(result) # This prints 8","title":"Evaluating Expressions"},{"location":"course/#variables_1","text":"","title":"Variables"},{"location":"course/#what-is-a-variable","text":"A variable is a named storage location in memory that holds a value. Variables allow you to store data and refer to it later in your program. You can think of a variable as a container for data.","title":"What is a Variable?"},{"location":"course/#declaring-and-initializing-variables","text":"To declare a variable, you simply assign a value to it using the equals sign ( = ). This process is called initialization. Examples: age = 16 # The variable age is assigned the value 16 name = \"Alice\" # The variable name is assigned the value \"Alice\" is_student = True # The variable is_student is assigned the value True","title":"Declaring and Initializing Variables"},{"location":"course/#using-variables","text":"Once you have declared a variable, you can use it in expressions, pass it to functions, and modify its value. Examples: # Using variables in expressions x = 10 y = 5 sum = x + y # sum is assigned the value 15 # Passing variables to functions def greet(person): print(f\"Hello, {person}!\") greet(name) # This prints \"Hello, Alice!\" # Modifying variables count = 0 count = count + 1 # count is now 1 count += 2 # count is now 3","title":"Using Variables"},{"location":"course/#variable-naming-rules","text":"When naming variables in Python, follow these rules: Use letters (a-z, A-Z), digits (0-9), and underscores (_). Do not start a variable name with a digit. Variable names are case-sensitive ( age and Age are different variables). Choose meaningful names that describe the data they hold. Valid examples: student_name = \"John\" total_score = 95 is_enrolled = True Invalid examples: 2nd_place = \"Bob\" # Starts with a digit total-score = 95 # Uses a hyphen instead of an underscore class = \"Math\" # Uses a reserved keyword","title":"Variable Naming Rules"},{"location":"course/#constants_1","text":"A constant is similar to a variable but is meant to remain unchanged throughout the program. By convention, constants are written in all uppercase letters. Examples: PI = 3.14159 MAX_STUDENTS = 30","title":"Constants"},{"location":"course/#importance-of-variables","text":"Variables are essential because they allow you to: Store and reuse values. Make your code more readable and maintainable. Write flexible and dynamic programs.","title":"Importance of Variables"},{"location":"course/#practice-time_2","text":"Try the following exercises to get comfortable with expressions and variables: Declare variables of different types (integer, float, string, boolean) and print their values. Write expressions that involve these variables and print the results. Create a function that takes a variable as an argument and performs an operation using that variable. Modify the values of your variables and observe how the output of your program changes. By mastering expressions and variables, you'll be well on your way to writing effective and powerful Python programs. Happy coding!","title":"Practice Time!"},{"location":"course/#assignments-in-python","text":"Assignments in Python are the process or tool used to store values in variables. They allow us to keep track of data and use it throughout our programs. In this section, we'll explore different types of assignments.","title":"Assignments in Python"},{"location":"course/#in-place-assignments","text":"In-place assignments allow you to update the value of a variable using its current value. This is done with special operators that combine assignment with an arithmetic operation.","title":"In-Place Assignments"},{"location":"course/#examples-of-in-place-assignments","text":"Addition Assignment ( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction Assignment ( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication Assignment ( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division Assignment ( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0 In-place assignments make your code more concise and can be easier to read.","title":"Examples of In-Place Assignments"},{"location":"course/#multiple-assignments","text":"Python allows you to assign values to multiple variables simultaneously. This can make your code more efficient and easier to read.","title":"Multiple Assignments"},{"location":"course/#examples-of-multiple-assignments","text":"Assigning Multiple Variables at Once x, y, z = 1, 2, 3 print(x) # Output: 1 print(y) # Output: 2 print(z) # Output: 3 Swapping Values Using Multiple Assignments a, b = 5, 10 a, b = b, a # Swaps the values of a and b print(a) # Output: 10 print(b) # Output: 5 Unpacking Values from a List or Tuple coordinates = (4, 5) x, y = coordinates print(x) # Output: 4 print(y) # Output: 5 Multiple assignments can be particularly useful when you need to initialize several variables at once or swap their values.","title":"Examples of Multiple Assignments"},{"location":"course/#two-variable-swap","text":"Swapping the values of two variables is a common task in programming. Python makes this easy with a simple syntax.","title":"Two-Variable Swap"},{"location":"course/#swapping-two-variables","text":"Traditional Swap Using a Temporary Variable x = 1 y = 2 temp = x x = y y = temp print(x) # Output: 2 print(y) # Output: 1 Pythonic Swap Using Multiple Assignments a = 3 b = 4 a, b = b, a # Swaps the values of a and b print(a) # Output: 4 print(b) # Output: 3 The Pythonic way of swapping values is more concise and avoids the need for a temporary variable, making your code cleaner.","title":"Swapping Two Variables"},{"location":"course/#practice-time_3","text":"Try the following exercises to get comfortable with assignments: In-Place Assignments: Start with a variable n = 10 . Use in-place assignments to add 5 to n , subtract 3 from n , multiply n by 2, and divide n by 4. Print the value of n after each operation. Multiple Assignments: Assign the values 10 , 20 , and 30 to the variables x , y , and z in a single line. Print the values of x , y , and z . Swap the values of x and z using multiple assignments. Print the values of x , y , and z again. Two-Variable Swap: Assign the values 15 and 25 to the variables a and b . Swap their values using both the traditional method and the Pythonic method. Print the values of a and b after each swap. By mastering these assignment techniques, you'll be able to write more efficient and readable Python code. Happy coding!","title":"Practice Time!"},{"location":"course/#operators","text":"Operators are special symbols in Python that perform operations on values and variables. They are the building blocks of expressions, allowing you to perform calculations, comparisons, and logical operations. In this section, we'll explore different types of operators and how to use them.","title":"Operators"},{"location":"course/#arithmetic-operators","text":"Arithmetic operators are used to perform basic mathematical operations like addition, subtraction, multiplication, and division.","title":"Arithmetic Operators"},{"location":"course/#examples-of-arithmetic-operators","text":"Addition ( + ) x = 5 y = 3 result = x + y # Adds x and y print(result) # Output: 8 Subtraction ( - ) x = 10 y = 4 result = x - y # Subtracts y from x print(result) # Output: 6 Multiplication ( * ) x = 7 y = 6 result = x * y # Multiplies x by y print(result) # Output: 42 Division ( / ) x = 20 y = 4 result = x / y # Divides x by y print(result) # Output: 5.0 Floor Division ( // ) x = 20 y = 3 result = x // y # Divides x by y and returns the integer part print(result) # Output: 6 Modulus ( % ) x = 10 y = 3 result = x % y # Returns the remainder of x divided by y print(result) # Output: 1 **Exponentiation ( ** )** x = 2 y = 3 result = x ** y # Raises x to the power of y print(result) # Output: 8","title":"Examples of Arithmetic Operators"},{"location":"course/#assignment-operators","text":"Assignment operators are used to assign values to variables. We've already seen the basic assignment operator ( = ), but there are also compound assignment operators that combine an arithmetic operation with assignment.","title":"Assignment Operators"},{"location":"course/#examples-of-assignment-operators","text":"Basic Assignment ( = ) x = 10 # Assigns the value 10 to x print(x) # Output: 10 Addition Assignment ( += ) x = 5 x += 3 # Equivalent to x = x + 3 print(x) # Output: 8 Subtraction Assignment ( -= ) y = 10 y -= 4 # Equivalent to y = y - 4 print(y) # Output: 6 Multiplication Assignment ( *= ) z = 7 z *= 2 # Equivalent to z = z * 2 print(z) # Output: 14 Division Assignment ( /= ) a = 20 a /= 4 # Equivalent to a = a / 4 print(a) # Output: 5.0 Modulus Assignment ( %= ) b = 10 b %= 3 # Equivalent to b = b % 3 print(b) # Output: 1 **Exponentiation Assignment ( **= )** c = 2 c **= 3 # Equivalent to c = c ** 3 print(c) # Output: 8 Floor Division Assignment ( //= ) d = 20 d //= 3 # Equivalent to d = d // 3 print(d) # Output: 6","title":"Examples of Assignment Operators"},{"location":"course/#comparison-operators","text":"Comparison operators are used to compare two values and return a Boolean result ( True or False ).","title":"Comparison Operators"},{"location":"course/#examples-of-comparison-operators","text":"Equal to ( == ) x = 5 y = 5 result = (x == y) # Checks if x is equal to y print(result) # Output: True Not equal to ( != ) x = 5 y = 3 result = (x != y) # Checks if x is not equal to y print(result) # Output: True Greater than ( > ) x = 7 y = 4 result = (x > y) # Checks if x is greater than y print(result) # Output: True Less than ( < ) x = 2 y = 8 result = (x < y) # Checks if x is less than y print(result) # Output: True Greater than or equal to ( >= ) x = 6 y = 6 result = (x >= y) # Checks if x is greater than or equal to y print(result) # Output: True Less than or equal to ( <= ) x = 3 y = 5 result = (x <= y) # Checks if x is less than or equal to y print(result) # Output: True","title":"Examples of Comparison Operators"},{"location":"course/#logical-operators","text":"Logical operators are used to combine multiple Boolean expressions.","title":"Logical Operators"},{"location":"course/#examples-of-logical-operators","text":"AND ( and ) x = True y = False result = x and y # Checks if both x and y are True print(result) # Output: False OR ( or ) x = True y = False result = x or y # Checks if either x or y is True print(result) # Output: True NOT ( not ) x = True result = not x # Inverts the value of x print(result) # Output: False","title":"Examples of Logical Operators"},{"location":"course/#identity-operators","text":"Identity operators are used to compare the memory locations of two objects.","title":"Identity Operators"},{"location":"course/#examples-of-identity-operators","text":"is x = [1, 2, 3] y = x z = [1, 2, 3] print(x is y) # Output: True, because y is the same object as x print(x is z) # Output: False, because z is a different object with the same contents is not a = 10 b = 20 print(a is not b) # Output: True, because a and b are not the same object","title":"Examples of Identity Operators"},{"location":"course/#membership-operators","text":"Membership operators are used to test if a sequence contains a certain value.","title":"Membership Operators"},{"location":"course/#examples-of-membership-operators","text":"in fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True, because \"banana\" is in the list not in fruits = [\"apple\", \"banana\", \"cherry\"] print(\"orange\" not in fruits) # Output: True, because \"orange\" is not in the list","title":"Examples of Membership Operators"},{"location":"course/#bitwise-operators","text":"Bitwise operators are used to perform operations on binary numbers.","title":"Bitwise Operators"},{"location":"course/#examples-of-bitwise-operators","text":"AND ( & ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x & y) # Output: 1 (0001 in binary) OR ( | ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x | y) # Output: 7 (0111 in binary) XOR ( ^ ) x = 5 # 0101 in binary y = 3 # 0011 in binary print(x ^ y) # Output: 6 (0110 in binary) NOT ( ~ ) x = 5 # 0101 in binary print(~x) # Output: -6 (inverts the bits, giving 1010 in binary, which is -6 in two's complement form) Left Shift ( << ) x = 5 # 0101 in binary print(x << 1) # Output: 10 (1010 in binary, shifts bits left by 1 position) Right Shift ( >> ) x = 5 # 0101 in binary print(x >> 1) # Output: 2 (0010 in binary, shifts bits right by 1 position)","title":"Examples of Bitwise Operators"},{"location":"course/#operator-precedence","text":"Operator precedence determines the order in which operators are evaluated in expressions. Operators with higher precedence are evaluated before operators with lower precedence.","title":"Operator Precedence"},{"location":"course/#examples-of-operator-precedence","text":"Arithmetic Operators x = 5 + 2 * 3 # Multiplication has higher precedence than addition print(x) # Output: 11 (2 * 3 is evaluated first, then 5 + 6) Using Parentheses to Change Precedence x = (5 + 2) * 3 # Parentheses change the order of evaluation print(x) # Output: 21 (5 + 2 is evaluated first, then 7 * 3) Combination of Different Operators x = 5 + 2 * 3 > 10 - 2 print(x) # Output: True (2 * 3 is evaluated first, then 5 + 6, then 10 - 2, finally 11 > 8) Here's a table summarizing the operator precedence in Python, from highest to lowest: Precedence Level Operators 1 (highest) () 2 ** 3 +x , -x , ~x 4 * , / , // , % 5 + , - 6 << , >> 7 & 8 ^ 9 binary or 10 in , not in , is , is not , < , <= , > , >= , != , == 11 not x 12 and 13 (lowest) or","title":"Examples of Operator Precedence"},{"location":"course/#practice-time_4","text":"Try the following exercises to get comfortable with operators: Arithmetic Operators: Perform addition, subtraction, multiplication, division, floor division, modulus, and exponentiation operations with different values and print the results. Comparison Operators: Compare two values using each of the comparison operators and print the results. Logical Operators: Combine multiple Boolean expressions using and , or , and not operators and print the results. Identity and Membership Operators: Use is , is not , in , and not in with different values and collections and print the results. Bitwise Operators: Perform bitwise AND, OR, XOR, NOT, left shift, and right shift operations and print the results. Operator Precedence: Write expressions using multiple operators and experiment with parentheses to change the order of evaluation. Print the results to see how operator precedence affects the outcome. Understanding and mastering operators will allow you to perform a wide range of operations in your Python programs, making your code more powerful and flexible. Happy coding!","title":"Practice Time!"},{"location":"course/#functions","text":"Functions are one of the most important building blocks in Python. They allow you to group code into reusable blocks, making your programs more modular, readable, and maintainable.","title":"Functions"},{"location":"course/#what-is-a-function","text":"A function is a block of code that performs a specific task. Functions help you to avoid repeating code by allowing you to define it once and reuse it as needed. Functions can take inputs, perform operations, and return outputs.","title":"What is a Function?"},{"location":"course/#defining-a-function","text":"To define a function in Python, use the def keyword followed by the function name and parentheses () which may include parameters. Example: def greet(name): print(f\"Hello, {name}!\")","title":"Defining a Function"},{"location":"course/#calling-a-function","text":"To call a function, simply use its name followed by parentheses, including any arguments required by the function. Example: greet(\"Alice\") # Output: Hello, Alice!","title":"Calling a Function"},{"location":"course/#parameters-and-arguments","text":"Parameters are variables defined in the function signature. Arguments are the values you pass to the function when you call it. Example: def add(a, b): return a + b result = add(3, 4) # Arguments 3 and 4 are passed to parameters a and b print(result) # Output: 7","title":"Parameters and Arguments"},{"location":"course/#return-statement","text":"The return statement is used to send a result back from the function to the caller. Once return is executed, the function terminates. Example: def square(x): return x * x result = square(5) print(result) # Output: 25","title":"Return Statement"},{"location":"course/#call-stack","text":"The call stack is a mechanism that keeps track of function calls. When a function is called, a frame is added to the stack. When the function returns, the frame is removed. The call stack helps manage the order in which functions are executed and their respective scopes. Example: def func1(): print(\"Start func1\") func2() print(\"End func1\") def func2(): print(\"Start func2\") func3() print(\"End func2\") def func3(): print(\"Start func3\") print(\"End func3\") func1() Output: Start func1 Start func2 Start func3 End func3 End func2 End func1 In this example, func1 calls func2 , and func2 calls func3 . The call stack manages these calls and ensures each function returns in the correct order.","title":"Call Stack"},{"location":"course/#traceback","text":"A traceback is a report that Python generates when an error occurs in your program. It shows the call stack at the point where the error happened, helping you to diagnose and fix issues. Example: def divide(x, y): return x / y result = divide(10, 0) Output: Traceback (most recent call last): File \"example.py\", line 5, in <module> result = divide(10, 0) File \"example.py\", line 2, in divide return x / y ZeroDivisionError: division by zero The traceback shows that the error occurred in the divide function because of a division by zero.","title":"Traceback"},{"location":"course/#function-scope-and-lifetime","text":"Variables defined inside a function are local to that function. They exist only during the function's execution and are not accessible outside. Example: def func(): x = 10 # x is local to func print(x) func() print(x) # Error: x is not defined outside func","title":"Function Scope and Lifetime"},{"location":"course/#recursive-functions","text":"A function that calls itself is known as a recursive function. Recursion can be used to solve problems that can be broken down into simpler, repetitive tasks. Example: def factorial(n): if n == 1: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120","title":"Recursive Functions"},{"location":"course/#practice-time_5","text":"Try the following exercises to get comfortable with functions: Basic Functions: Write a function multiply that takes two arguments and returns their product. Write a function is_even that returns True if a number is even and False otherwise. Using Return Statements: Write a function max_of_three that takes three numbers as arguments and returns the maximum of the three. Write a function sum_of_squares that returns the sum of the squares of two numbers. Understanding the Call Stack: Write a series of nested function calls to see the call stack in action. Use print statements to show the flow of execution. Handling Tracebacks: Intentionally create a function that will generate an error (e.g., division by zero) and observe the traceback. Modify the function to handle the error gracefully. Recursion: Write a recursive function fibonacci that returns the nth Fibonacci number. Write a recursive function to calculate the greatest common divisor (GCD) of two numbers. Understanding functions, return statements, the call stack, and tracebacks will give you a strong foundation in writing modular and error-resistant Python code. Happy coding!","title":"Practice Time!"},{"location":"course/#conditionals","text":"Conditionals allow you to execute different code based on certain conditions. They are fundamental to controlling the flow of your programs, making decisions, and performing actions based on those decisions.","title":"Conditionals"},{"location":"course/#if-statements","text":"The if statement is used to test a condition. If the condition is True , the code block inside the if statement is executed.","title":"If Statements"},{"location":"course/#example","text":"age = 18 if age >= 18: print(\"You are an adult.\")","title":"Example:"},{"location":"course/#else-statements","text":"The else statement is used in conjunction with the if statement. It defines a block of code that will be executed if the if condition is False .","title":"Else Statements"},{"location":"course/#example_1","text":"age = 16 if age >= 18: print(\"You are an adult.\") else: print(\"You are a minor.\")","title":"Example:"},{"location":"course/#elif-statements","text":"The elif (short for \"else if\") statement allows you to check multiple conditions. If the first if condition is False , the program checks the elif conditions in order. If one of the elif conditions is True , its block of code is executed.","title":"Elif Statements"},{"location":"course/#example_2","text":"score = 85 if score >= 90: print(\"Grade: A\") elif score >= 80: print(\"Grade: B\") elif score >= 70: print(\"Grade: C\") elif score >= 60: print(\"Grade: D\") else: print(\"Grade: F\")","title":"Example:"},{"location":"course/#nested-if-statements","text":"You can nest if , elif , and else statements inside other if , elif , and else statements to create more complex conditions.","title":"Nested If Statements"},{"location":"course/#example_3","text":"num = 15 if num % 2 == 0: print(\"The number is even.\") else: print(\"The number is odd.\") if num % 3 == 0: print(\"The number is also divisible by 3.\")","title":"Example:"},{"location":"course/#conditional-expressions-ternary-operator","text":"A conditional expression, also known as a ternary operator, allows you to write a simple if-else statement in one line.","title":"Conditional Expressions (Ternary Operator)"},{"location":"course/#example_4","text":"age = 18 status = \"adult\" if age >= 18 else \"minor\" print(status) # Output: adult","title":"Example:"},{"location":"course/#combining-conditions","text":"You can combine multiple conditions using logical operators and , or , and not to create more complex conditional statements.","title":"Combining Conditions"},{"location":"course/#examples","text":"Using and : num = 10 if num > 5 and num < 15: print(\"The number is between 5 and 15.\") Using or : day = \"Saturday\" if day == \"Saturday\" or day == \"Sunday\": print(\"It's the weekend!\") Using not : is_raining = False if not is_raining: print(\"It's not raining, you can go outside.\")","title":"Examples:"},{"location":"course/#practice-time_6","text":"Try the following exercises to get comfortable with conditionals: Basic If-Else: Write a program that checks if a number is positive, negative, or zero and prints the result. Grading System: Modify the grading example to include a condition for \"A+\" grade if the score is 95 or higher. Nested Conditionals: Write a program that checks if a year is a leap year. A leap year is divisible by 4 but not by 100, except if it is also divisible by 400. Ternary Operator: Use a conditional expression to set a variable parity to \"even\" if a number is even and \"odd\" if it is odd. Combining Conditions: Write a program that checks if a person can vote. A person can vote if they are at least 18 years old and a citizen. Understanding and using conditionals will enable you to create programs that can make decisions based on different inputs and scenarios, making your code more dynamic and interactive. Happy coding!","title":"Practice Time!"},{"location":"course/#lists","text":"Lists are one of the most versatile and commonly used data structures in Python. They allow you to store collections of items in a single variable, making it easy to organize and manipulate data.","title":"Lists"},{"location":"course/#creating-lists","text":"A list is created by placing all the items (elements) inside square brackets [] , separated by commas.","title":"Creating Lists"},{"location":"course/#examples_1","text":"# A list of integers numbers = [1, 2, 3, 4, 5] # A list of strings fruits = [\"apple\", \"banana\", \"cherry\"] # A mixed list mixed = [1, \"hello\", 3.14, True]","title":"Examples:"},{"location":"course/#accessing-list-elements","text":"You can access individual elements in a list using their index. Python uses zero-based indexing, meaning the first element has an index of 0.","title":"Accessing List Elements"},{"location":"course/#examples_2","text":"fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple print(fruits[2]) # Output: cherry # Accessing elements from the end print(fruits[-1]) # Output: cherry print(fruits[-2]) # Output: banana","title":"Examples:"},{"location":"course/#modifying-lists","text":"Lists are mutable, meaning you can change their elements after they have been created.","title":"Modifying Lists"},{"location":"course/#examples_3","text":"fruits = [\"apple\", \"banana\", \"cherry\"] # Changing an element fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry'] # Adding elements fruits.append(\"date\") print(fruits) # Output: ['apple', 'blueberry', 'cherry', 'date'] # Inserting elements fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'blueberry', 'cherry', 'date'] # Removing elements fruits.remove(\"blueberry\") print(fruits) # Output: ['apple', 'banana', 'cherry', 'date']","title":"Examples:"},{"location":"course/#list-operations","text":"Python provides many built-in methods and operations that you can use to manipulate lists.","title":"List Operations"},{"location":"course/#examples_4","text":"Length of a List: numbers = [1, 2, 3, 4, 5] print(len(numbers)) # Output: 5 Concatenation: list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6] Repetition: fruits = [\"apple\", \"banana\"] print(fruits * 3) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana'] Slicing: numbers = [1, 2, 3, 4, 5] print(numbers[1:4]) # Output: [2, 3, 4] print(numbers[:3]) # Output: [1, 2, 3] print(numbers[2:]) # Output: [3, 4, 5] Checking Membership: fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"date\" not in fruits) # Output: True","title":"Examples:"},{"location":"course/#list-comprehensions","text":"List comprehensions provide a concise way to create lists. They can be used to generate new lists by applying an expression to each element in an existing list.","title":"List Comprehensions"},{"location":"course/#example_5","text":"# Creating a list of squares squares = [x ** 2 for x in range(1, 6)] print(squares) # Output: [1, 4, 9, 16, 25]","title":"Example:"},{"location":"course/#common-list-methods","text":"append() : Adds an element to the end of the list. fruits = [\"apple\", \"banana\"] fruits.append(\"cherry\") print(fruits) # Output: ['apple', 'banana', 'cherry'] insert() : Inserts an element at a specified position. fruits = [\"apple\", \"cherry\"] fruits.insert(1, \"banana\") print(fruits) # Output: ['apple', 'banana', 'cherry'] remove() : Removes the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] fruits.remove(\"banana\") print(fruits) # Output: ['apple', 'cherry'] pop() : Removes and returns the element at a specified position (default is the last element). fruits = [\"apple\", \"banana\", \"cherry\"] fruit = fruits.pop() print(fruit) # Output: cherry print(fruits) # Output: ['apple', 'banana'] index() : Returns the index of the first occurrence of a specified element. fruits = [\"apple\", \"banana\", \"cherry\"] index = fruits.index(\"banana\") print(index) # Output: 1 count() : Returns the number of times a specified element appears in the list. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] count = fruits.count(\"banana\") print(count) # Output: 2 sort() : Sorts the list in ascending order. numbers = [4, 2, 3, 1, 5] numbers.sort() print(numbers) # Output: [1, 2, 3, 4, 5] reverse() : Reverses the order of the list. numbers = [1, 2, 3, 4, 5] numbers.reverse() print(numbers) # Output: [5, 4, 3, 2, 1]","title":"Common List Methods"},{"location":"course/#practice-time_7","text":"Try the following exercises to get comfortable with lists: Basic List Operations: Create a list of your favorite movies. Add a new movie to the list, remove one movie, and print the updated list. List Slicing: Given a list of numbers, create a new list containing only the first half of the original list. List Comprehensions: Create a list of the first 10 even numbers using a list comprehension. Using List Methods: Write a program that asks the user to input their top 5 favorite foods and then prints the list in alphabetical order. Combining Lists: Create two lists of different subjects you are studying this semester. Combine them into one list and print the combined list. By mastering lists, you'll be able to store and manipulate collections of data efficiently, making your Python programs more powerful and flexible. Happy coding!","title":"Practice Time!"},{"location":"course/#loops","text":"Loops allow you to execute a block of code multiple times, making your programs more efficient and reducing the need for repetitive code. In Python, there are two main types of loops: for loops and while loops.","title":"Loops"},{"location":"course/#for-loops","text":"A for loop is used to iterate over a sequence (such as a list, tuple, string, or range) and execute a block of code for each item in the sequence.","title":"For Loops"},{"location":"course/#syntax","text":"for variable in sequence: # Code to execute for each item","title":"Syntax:"},{"location":"course/#examples_5","text":"Iterating Over a List: fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(fruit) Using the range() Function: for i in range(5): print(i) Iterating Over a String: for letter in \"hello\": print(letter)","title":"Examples:"},{"location":"course/#while-loops","text":"A while loop continues to execute as long as a specified condition is True . It is useful when the number of iterations is not known beforehand.","title":"While Loops"},{"location":"course/#syntax_1","text":"while condition: # Code to execute while the condition is True","title":"Syntax:"},{"location":"course/#examples_6","text":"Basic while Loop: count = 0 while count < 5: print(count) count += 1 Using a while Loop for User Input: user_input = \"\" while user_input != \"exit\": user_input = input(\"Type 'exit' to stop: \")","title":"Examples:"},{"location":"course/#nested-loops","text":"You can nest loops inside other loops to perform more complex iterations. Each iteration of the outer loop triggers the complete execution of the inner loop.","title":"Nested Loops"},{"location":"course/#example_6","text":"for i in range(3): for j in range(2): print(f\"i = {i}, j = {j}\")","title":"Example:"},{"location":"course/#loop-control-statements","text":"Python provides several statements to control the execution of loops: break : Terminates the loop prematurely. for i in range(10): if i == 5: break print(i) continue : Skips the current iteration and proceeds to the next iteration. for i in range(5): if i == 3: continue print(i) else : Executes a block of code after the loop finishes, unless the loop is terminated by a break statement. for i in range(5): print(i) else: print(\"Loop finished successfully\")","title":"Loop Control Statements"},{"location":"course/#using-loops-with-lists","text":"Loops are often used to iterate over lists and perform operations on each element.","title":"Using Loops with Lists"},{"location":"course/#examples_7","text":"Calculating the Sum of a List: numbers = [1, 2, 3, 4, 5] total = 0 for number in numbers: total += number print(\"Total:\", total) Finding the Maximum Element in a List: numbers = [3, 7, 2, 5, 9] max_number = numbers[0] for number in numbers: if number > max_number: max_number = number print(\"Maximum number:\", max_number) Using a while Loop to Create a List: even_numbers = [] num = 2 while num <= 10: even_numbers.append(num) num += 2 print(\"Even numbers:\", even_numbers)","title":"Examples:"},{"location":"course/#practice-time_8","text":"Try the following exercises to get comfortable with loops: Basic for Loop: Write a for loop that prints the numbers from 1 to 10. Basic while Loop: Write a while loop that prints the numbers from 10 to 1. Nested Loops: Write a nested loop to print a multiplication table from 1 to 5. Loop Control Statements: Write a loop that prints numbers from 1 to 20, but skips multiples of 3 using the continue statement. Write a loop that prints numbers from 1 to 10, but stops the loop if the number is 7 using the break statement. Working with Lists: Write a program that calculates the average of a list of numbers using a for loop. Write a program that finds the smallest number in a list using a for loop. By mastering loops, you'll be able to write more efficient and powerful programs that can handle repetitive tasks with ease. Happy coding!","title":"Practice Time!"},{"location":"course/#boolean-expressions","text":"Boolean expressions are expressions that evaluate to either True or False . They are fundamental to decision-making in programming, allowing you to control the flow of your code based on conditions.","title":"Boolean Expressions"},{"location":"course/#boolean-values","text":"Python has two boolean values: True and False . These values are the result of boolean expressions and are used in conditional statements, loops, and other control structures.","title":"Boolean Values"},{"location":"course/#examples_8","text":"is_raining = True is_sunny = False","title":"Examples:"},{"location":"course/#comparison-operators_1","text":"Comparison operators are used to compare two values and produce a boolean result ( True or False ).","title":"Comparison Operators"},{"location":"course/#examples-of-comparison-operators_1","text":"Equal to ( == ) x = 5 y = 5 print(x == y) # Output: True Not equal to ( != ) x = 5 y = 3 print(x != y) # Output: True Greater than ( > ) x = 7 y = 4 print(x > y) # Output: True Less than ( < ) x = 2 y = 8 print(x < y) # Output: True Greater than or equal to ( >= ) x = 6 y = 6 print(x >= y) # Output: True Less than or equal to ( <= ) x = 3 y = 5 print(x <= y) # Output: True","title":"Examples of Comparison Operators:"},{"location":"course/#logical-operators_1","text":"Logical operators are used to combine multiple boolean expressions and return a boolean result.","title":"Logical Operators"},{"location":"course/#examples-of-logical-operators_1","text":"AND ( and ) x = True y = False print(x and y) # Output: False OR ( or ) x = True y = False print(x or y) # Output: True NOT ( not ) x = True print(not x) # Output: False","title":"Examples of Logical Operators:"},{"location":"course/#pythonic-booleans","text":"Python has a concept of \"truthy\" and \"falsy\" values, where certain values are implicitly converted to True or False in a boolean context.","title":"Pythonic Booleans"},{"location":"course/#truthy-values","text":"Non-zero numbers Non-empty strings Non-empty collections (lists, tuples, dictionaries, etc.)","title":"Truthy Values:"},{"location":"course/#falsy-values","text":"None False Zero ( 0 , 0.0 , 0j ) Empty strings ( \"\" ) Empty collections ( [] , () , {} )","title":"Falsy Values:"},{"location":"course/#examples_9","text":"if 0: print(\"This is truthy.\") else: print(\"This is falsy.\") # Output: This is falsy. if \"hello\": print(\"This is truthy.\") # Output: This is truthy. else: print(\"This is falsy.\")","title":"Examples:"},{"location":"course/#shortcutting","text":"Shortcutting (short-circuit evaluation) is a feature in Python where logical operators and and or stop evaluating as soon as the result is determined. This can make your code more efficient by avoiding unnecessary computations.","title":"Shortcutting"},{"location":"course/#basic-examples","text":"AND Shortcutting: In an AND operation, if any operand is False , the whole expression is False , and evaluation stops immediately. a = False b = True result = a and b print(result) # Output: False Here, a is False , so b is not evaluated because the result is already determined to be False . OR Shortcutting: In an OR operation, if any operand is True , the whole expression is True , and evaluation stops immediately. a = True b = False result = a or b print(result) # Output: True Here, a is True , so b is not evaluated because the result is already determined to be True .","title":"Basic Examples:"},{"location":"course/#practical-applications","text":"Avoiding Errors with Shortcutting: You can use shortcutting to prevent errors by ensuring that certain conditions are met before performing operations. user_input = None # Avoiding attribute error by checking for None if user_input and user_input.strip() != \"\": print(f\"User input: {user_input.strip()}\") else: print(\"No valid input provided.\") In this example, user_input.strip() is only called if user_input is not None , preventing a potential AttributeError . Conditional Execution: Use shortcutting to conditionally execute functions or expressions only when necessary. def expensive_operation(): print(\"Expensive operation executed.\") return True condition = False # Expensive operation will not execute because condition is False result = condition and expensive_operation() print(result) # Output: False In this example, expensive_operation is not called because condition is False . Setting Default Values: Use shortcutting with the or operator to provide default values. primary_value = None secondary_value = \"Secondary\" default_value = \"Default\" # Uses secondary_value because primary_value is None result = primary_value or secondary_value or default_value print(result) # Output: Secondary Here, secondary_value is used because primary_value is None . Input Validation: Use shortcutting to validate multiple conditions in user input. password = \"mypassword123\" # Check if password is valid: at least 8 characters, contains a digit, and contains a letter is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if all conditions are true. If the first condition fails, the subsequent checks are not performed. Short-Circuiting with Function Calls: Use shortcutting to decide whether to call a function based on certain conditions. def greet(): print(\"Hello!\") name = \"Alice\" # Greet only if name is not empty name and greet() # Output: Hello! In this example, greet() is called only if name is not an empty string.","title":"Practical Applications:"},{"location":"course/#summary","text":"Shortcutting allows you to optimize your code by stopping evaluation as soon as the result is determined. This feature is useful for preventing errors, improving performance, and making your code more concise. By understanding how shortcutting works, you can effectively use it to handle conditional execution, validate inputs, and manage complex logical flows in your programs.","title":"Summary:"},{"location":"course/#chaining","text":"You can chain multiple comparisons together in a single expression.","title":"Chaining"},{"location":"course/#example_7","text":"x = 5 print(1 < x < 10) # Output: True print(10 < x < 20) # Output: False The idea here is that the first value that defines the result in a chained expression is returned: a or b or c or d a and b and c and d","title":"Example:"},{"location":"course/#applications","text":"Finding the First Truthy Value (OR Chaining): In an OR chain, the first truthy value is returned, or the last value if none are truthy. a = None b = \"\" c = 0 d = \"Python\" result = a or b or c or d print(result) # Output: Python In this example, d is the first truthy value, so it is returned. Ensuring All Conditions are True (AND Chaining): In an AND chain, the first falsy value is returned, or the last value if all are truthy. a = True b = 5 > 3 c = 10 == 10 d = 0 # This is falsy result = a and b and c and d print(result) # Output: 0 In this example, d is the first falsy value, so it is returned. Default Values with OR Chaining: You can use OR chaining to provide default values if previous values are falsy. username = input(\"Enter your username: \") or \"Guest\" print(f\"Welcome, {username}!\") If the user inputs an empty string, \"Guest\" is used as the default value. Checking Multiple Conditions with AND Chaining: You can use AND chaining to ensure multiple conditions are met. age = 25 has_permission = True is_member = True if age > 18 and has_permission and is_member: print(\"Access granted.\") else: print(\"Access denied.\") In this example, access is granted only if all conditions are true. Conditional Assignment: You can use chaining to assign values based on multiple conditions. score = 85 grade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'D' if score >= 60 else 'F' print(f\"Your grade is: {grade}\") This example assigns a grade based on the score using chained comparisons. Validating User Input: Chaining can be used to validate multiple conditions in user input. password = \"mypassword123\" is_valid = len(password) >= 8 and any(char.isdigit() for char in password) and any(char.isalpha() for char in password) print(f\"Password is valid: {is_valid}\") In this example, the password is considered valid if it is at least 8 characters long, contains at least one digit, and contains at least one letter.","title":"Applications:"},{"location":"course/#summary_1","text":"Chaining allows you to combine multiple comparisons and logical operations into a single, concise expression. This technique is useful for simplifying code and making it more readable. By understanding how chaining works, you can effectively use it to handle default values, validate conditions, and manage complex logical flows in your programs.","title":"Summary:"},{"location":"course/#boolean-return-values","text":"Functions can return boolean values, making them useful for complex conditions. Imagine we are trying to write down a function that checks if we're allowed to sleep in or not in a certain day, evaluating whether this day is a weekday or not, and if we are on vacation or not. We could write down something like this to solve the problem: def sleep_in(weekday, vacation): if weekday == True and vacation == False: return False else return True Even though the solution above is correct, it is not a pythonic way of doing things. We could do this instead: def sleep_in(weekday, vacation): return not (weekday == True and vacation == False)","title":"Boolean Return Values"},{"location":"course/#practice-time_9","text":"Try the following exercises to get comfortable with boolean expressions: Comparison Operators: Write a program that compares two numbers and prints whether the first is greater than, less than, or equal to the second. Logical Operators: Write a program that checks if a number is within a specified range (e.g., between 10 and 20) using logical operators. Boolean Expressions in Conditionals: Write a program that asks the user for their age and prints whether they are a child (under 13), a teenager (13-19), or an adult (20 and above). Pythonic Booleans: Write a program that takes a list and prints True if the list is not empty and False if it is empty. Shortcutting: Write a program that uses logical operators with shortcutting to determine if certain conditions are met. Chaining: Write a program that takes three numbers and prints the largest one using chained comparison operators. Boolean Return Values: Write a function that checks if a number is both positive and even, returning True or False . Understanding boolean expressions is crucial for controlling the flow of your programs and making decisions based on conditions. Mastering these concepts will make you a more effective and efficient programmer. Happy coding!","title":"Practice Time!"},{"location":"course/#recursion","text":"Recursion is a powerful programming technique where a function calls itself in order to solve smaller instances of the same problem. It is particularly useful for problems that can be broken down into simpler, repetitive tasks.","title":"Recursion"},{"location":"course/#what-is-recursion","text":"Recursion occurs when a function calls itself. A recursive function must have a base case that stops the recursion and one or more recursive cases that break the problem into smaller instances and call the function itself.","title":"What is Recursion?"},{"location":"course/#basic-structure-of-a-recursive-function","text":"def recursive_function(parameters): if base_case_condition: return base_case_value else: # Recursive case return recursive_function(modified_parameters)","title":"Basic Structure of a Recursive Function:"},{"location":"course/#example-factorial-function","text":"The factorial of a non-negative integer n is the product of all positive integers less than or equal to n . It can be defined recursively as: factorial(0) = 1 (base case) factorial(n) = n * factorial(n-1) (recursive case) def factorial(n): if n == 0: return 1 else: return n * factorial(n - 1) print(factorial(5)) # Output: 120","title":"Example: Factorial Function"},{"location":"course/#practical-applications-of-recursion","text":"Calculating Fibonacci Numbers: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. It can be defined recursively as: fibonacci(0) = 0 (base case) fibonacci(1) = 1 (base case) fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) (recursive case) def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2) print(fibonacci(7)) # Output: 13 Sum of a List: You can use recursion to find the sum of a list of numbers. def sum_list(numbers): if len(numbers) == 0: return 0 else: return numbers[0] + sum_list(numbers[1:]) print(sum_list([1, 2, 3, 4, 5])) # Output: 15 Binary Search: Binary search is an efficient algorithm for finding an item in a sorted list. It works by repeatedly dividing the list in half and comparing the target value to the middle element. def binary_search(arr, target, low, high): if low > high: return -1 # Base case: target not found mid = (low + high) // 2 if arr[mid] == target: return mid # Base case: target found elif arr[mid] > target: return binary_search(arr, target, low, mid - 1) # Search left half else: return binary_search(arr, target, mid + 1, high) # Search right half numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 6 print(binary_search(numbers, target, 0, len(numbers) - 1)) # Output: 5 Towers of Hanoi: The Towers of Hanoi is a classic problem where you have three pegs and a number of disks of different sizes. The goal is to move all the disks from one peg to another, following these rules: Only one disk can be moved at a time. A disk can only be placed on top of a larger disk. def towers_of_hanoi(n, source, target, auxiliary): if n == 1: print(f\"Move disk 1 from {source} to {target}\") else: towers_of_hanoi(n - 1, source, auxiliary, target) print(f\"Move disk {n} from {source} to {target}\") towers_of_hanoi(n - 1, auxiliary, target, source) towers_of_hanoi(3, 'A', 'C', 'B')","title":"Practical Applications of Recursion"},{"location":"course/#output","text":"Move disk 1 from A to C Move disk 2 from A to B Move disk 1 from C to B Move disk 3 from A to C Move disk 1 from B to A Move disk 2 from B to C Move disk 1 from A to C","title":"Output:"},{"location":"course/#advantages-of-recursion","text":"Simplicity: Recursive solutions are often more straightforward and easier to understand than their iterative counterparts. Elegance: Recursive functions can solve complex problems with minimal code.","title":"Advantages of Recursion"},{"location":"course/#disadvantages-of-recursion","text":"Performance: Recursive functions can be less efficient and use more memory than iterative solutions due to the overhead of multiple function calls. Stack Overflow: Deep recursion can lead to stack overflow errors if the recursion depth exceeds the maximum stack size.","title":"Disadvantages of Recursion"},{"location":"course/#tips-for-using-recursion","text":"Identify the Base Case: Ensure your recursive function has a well-defined base case to prevent infinite recursion. Simplify the Problem: Break the problem into smaller subproblems that are easier to solve. Avoid Redundant Calculations: Use memoization or caching to store results of expensive recursive calls to improve performance.","title":"Tips for Using Recursion"},{"location":"course/#practice-time_10","text":"Try the following exercises to get comfortable with recursion: Recursive Factorial: Write a recursive function to calculate the factorial of a number. Recursive Fibonacci: Write a recursive function to calculate the nth Fibonacci number. Sum of a List: Write a recursive function to find the sum of a list of numbers. Binary Search: Implement a recursive binary search function to find an element in a sorted list. Towers of Hanoi: Solve the Towers of Hanoi problem for 4 disks. Understanding recursion is crucial for solving many types of problems efficiently. By mastering recursive thinking, you'll be able to tackle complex tasks with elegant and powerful solutions. Happy coding!","title":"Practice Time!"},{"location":"course/#sequences","text":"Sequences are a fundamental concept in Python that represent ordered collections of items. They allow you to store multiple values in a single variable and perform a variety of operations on them. Python provides several built-in sequence types, including lists, tuples, strings, and ranges.","title":"Sequences"},{"location":"course/#types-of-sequences","text":"There are several types of sequences in Python. Here are some of them:","title":"Types of Sequences"},{"location":"course/#lists_1","text":"Lists are mutable sequences, meaning their elements can be changed after the list is created. Lists are defined using square brackets [] . # Creating a list fruits = [\"apple\", \"banana\", \"cherry\"] # Accessing elements print(fruits[0]) # Output: apple # Modifying elements fruits[1] = \"blueberry\" print(fruits) # Output: ['apple', 'blueberry', 'cherry']","title":"Lists"},{"location":"course/#tuples","text":"Tuples are immutable sequences, meaning their elements cannot be changed after the tuple is created. Tuples are defined using parentheses () . # Creating a tuple coordinates = (10.0, 20.0) # Accessing elements print(coordinates[0]) # Output: 10.0 # Tuples cannot be modified # coordinates[1] = 30.0 # This will raise a TypeError","title":"Tuples"},{"location":"course/#strings","text":"Strings are immutable sequences of characters. Strings are defined using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . # Creating a string greeting = \"Hello, world!\" # Accessing characters print(greeting[0]) # Output: H # Strings cannot be modified # greeting[0] = \"h\" # This will raise a TypeError","title":"Strings"},{"location":"course/#ranges","text":"Ranges represent immutable sequences of numbers and are commonly used for looping a specific number of times in for loops. They are defined using the range() function. # Creating a range numbers = range(5) # Converting range to list to view elements print(list(numbers)) # Output: [0, 1, 2, 3, 4] # Using range in a for loop for i in range(5): print(i) # Output: 0, 1, 2, 3, 4","title":"Ranges"},{"location":"course/#common-sequence-operations","text":"","title":"Common Sequence Operations"},{"location":"course/#length","text":"You can use the len() function to get the number of elements in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(len(fruits)) # Output: 3","title":"Length"},{"location":"course/#concatenation","text":"You can concatenate sequences of the same type using the + operator. list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 + list2 print(combined) # Output: [1, 2, 3, 4, 5, 6]","title":"Concatenation"},{"location":"course/#repetition","text":"You can repeat sequences using the * operator. fruits = [\"apple\", \"banana\"] repeated_fruits = fruits * 3 print(repeated_fruits) # Output: ['apple', 'banana', 'apple', 'banana', 'apple', 'banana']","title":"Repetition"},{"location":"course/#membership","text":"You can check if an item is in a sequence using the in operator. fruits = [\"apple\", \"banana\", \"cherry\"] print(\"banana\" in fruits) # Output: True print(\"orange\" in fruits) # Output: False","title":"Membership"},{"location":"course/#slicing","text":"You can extract a subset of a sequence using slicing. The syntax is sequence[start:stop:step] . # Creating a list numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # Slicing from index 2 to 5 print(numbers[2:6]) # Output: [2, 3, 4, 5] # Slicing with a step print(numbers[::2]) # Output: [0, 2, 4, 6, 8] # Reversing a sequence print(numbers[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]","title":"Slicing"},{"location":"course/#sequence-functions-and-methods","text":"Here are some of the most used functions and methods involving sequences:","title":"Sequence Functions and Methods"},{"location":"course/#min-and-max","text":"You can use the min() and max() functions to find the smallest and largest elements in a sequence. numbers = [1, 2, 3, 4, 5] print(min(numbers)) # Output: 1 print(max(numbers)) # Output: 5","title":"min() and max()"},{"location":"course/#sum","text":"You can use the sum() function to calculate the sum of elements in a sequence. numbers = [1, 2, 3, 4, 5] print(sum(numbers)) # Output: 15","title":"sum()"},{"location":"course/#index","text":"You can use the index() method to find the first occurrence of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\"] print(fruits.index(\"banana\")) # Output: 1","title":"index()"},{"location":"course/#count","text":"You can use the count() method to count the number of occurrences of an element in a sequence. fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"] print(fruits.count(\"banana\")) # Output: 2","title":"count()"},{"location":"course/#practice-time_11","text":"Try the following exercises to get comfortable with sequences: List Operations: Create a list of your favorite movies. Add a new movie to the list, remove one movie, and print the updated list. Tuple Operations: Create a tuple with five elements. Access and print the second and fourth elements. String Operations: Create a string and use slicing to print the first five characters, the last three characters, and the string in reverse. Range Operations: Use the range() function to create a list of even numbers from 0 to 20 and print the list. Sequence Functions: Write a program to find the minimum, maximum, and sum of a list of numbers. Membership and Indexing: Create a list of fruits. Check if \"apple\" is in the list, find the index of \"banana\", and count how many times \"cherry\" appears in the list. Understanding sequences and how to manipulate them is crucial for working with data in Python. By mastering these concepts, you'll be able to store, access, and process collections of data efficiently. Happy coding!","title":"Practice Time!"},{"location":"course/#string-manipulation","text":"Strings are sequences of characters, and Python provides a variety of methods and operations to manipulate strings. Understanding how to work with strings is essential for tasks like processing text data, building user interfaces, and more.","title":"String Manipulation"},{"location":"course/#creating-strings","text":"Strings can be created using single quotes '' , double quotes \"\" , or triple quotes ''' / \"\"\" . single_quote_string = 'Hello' double_quote_string = \"World\" triple_quote_string = '''This is a multi-line string.'''","title":"Creating Strings"},{"location":"course/#accessing-characters-in-a-string","text":"You can access individual characters in a string using indexing. Python uses zero-based indexing. greeting = \"Hello, World!\" # Accessing characters print(greeting[0]) # Output: H print(greeting[-1]) # Output: !","title":"Accessing Characters in a String"},{"location":"course/#slicing-strings","text":"Slicing allows you to extract a substring from a string. The syntax is string[start:stop:step] . # Creating a string greeting = \"Hello, World!\" # Slicing the string print(greeting[0:5]) # Output: Hello print(greeting[7:12]) # Output: World print(greeting[::2]) # Output: Hlo ol!","title":"Slicing Strings"},{"location":"course/#string-methods","text":"Python provides many built-in methods to manipulate strings. Here are some commonly used string methods:","title":"String Methods"},{"location":"course/#changing-case","text":"upper() : Converts all characters to uppercase. lower() : Converts all characters to lowercase. capitalize() : Capitalizes the first character of the string. message = \"hello, world!\" print(message.upper()) # Output: HELLO, WORLD! print(message.lower()) # Output: hello, world! print(message.capitalize()) # Output: Hello, world!","title":"Changing Case"},{"location":"course/#stripping-whitespace","text":"strip() : Removes leading and trailing whitespace. lstrip() : Removes leading whitespace. rstrip() : Removes trailing whitespace. message = \" Hello, World! \" print(message.strip()) # Output: Hello, World! print(message.lstrip()) # Output: Hello, World! print(message.rstrip()) # Output: Hello, World!","title":"Stripping Whitespace"},{"location":"course/#finding-and-replacing","text":"find() : Returns the index of the first occurrence of a substring. replace() : Replaces all occurrences of a substring with another substring. message = \"Hello, World!\" print(message.find(\"World\")) # Output: 7 print(message.replace(\"World\", \"Python\")) # Output: Hello, Python!","title":"Finding and Replacing"},{"location":"course/#splitting-and-joining","text":"split() : Splits the string into a list of substrings based on a delimiter. join() : Joins a list of strings into a single string with a specified delimiter. message = \"Hello, World! How are you?\" words = message.split() print(words) # Output: ['Hello,', 'World!', 'How', 'are', 'you?'] joined_message = \" \".join(words) print(joined_message) # Output: Hello, World! How are you?","title":"Splitting and Joining"},{"location":"course/#string-formatting","text":"String formatting allows you to create strings with dynamic content. name = \"Alice\" age = 30 message = f\"My name is {name} and I am {age} years old.\" print(message) # Output: My name is Alice and I am 30 years old.","title":"String Formatting"},{"location":"course/#practical-applications_1","text":"Validating User Input: You can use string methods to validate and clean user input. user_input = \" Hello, Python! \" # Strip leading/trailing whitespace and convert to uppercase cleaned_input = user_input.strip().upper() print(cleaned_input) # Output: HELLO, PYTHON! Parsing CSV Data: You can use string splitting to parse CSV (Comma-Separated Values) data. csv_data = \"name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\" # Split into lines lines = csv_data.split(\"\\n\") # Process each line for line in lines: fields = line.split(\",\") print(fields) # Output: ['name', 'age', 'city'], ['Alice', '30', 'New York'], ['Bob', '25', 'Los Angeles'] Creating Slugs for URLs: You can use string manipulation to create URL-friendly slugs. title = \"Hello, World! Welcome to Python.\" # Convert to lowercase, replace spaces with hyphens, and remove punctuation slug = title.lower().replace(\" \", \"-\").replace(\"!\", \"\").replace(\",\", \"\").replace(\".\", \"\") print(slug) # Output: hello-world-welcome-to-python","title":"Practical Applications"},{"location":"course/#practice-time_12","text":"Try the following exercises to get comfortable with string manipulation: Basic String Operations: Create a string and use slicing to print the first five characters, the last three characters, and the string in reverse. String Methods: Write a program that takes a string input from the user, converts it to uppercase, and removes any leading or trailing whitespace. Finding and Replacing: Write a program that replaces all occurrences of \"Python\" with \"JavaScript\" in a given string. Splitting and Joining: Write a program that splits a sentence into words, then joins the words with a hyphen ( - ) and prints the result. String Formatting: Write a program that takes a user's name and age as input and prints a formatted message using both the format() method and f-strings. By mastering string manipulation, you'll be able to handle text data efficiently and create dynamic and interactive programs. Happy coding!","title":"Practice Time!"},{"location":"course/#exceptions-and-exception-handling-in-python","text":"Exceptions are errors that occur during the execution of a program. When an exception occurs, the normal flow of the program is interrupted, and Python raises an error message. Exception handling allows you to manage these errors gracefully and maintain the flow of your program.","title":"Exceptions and Exception Handling in Python"},{"location":"course/#understanding-exceptions","text":"An exception is an event that disrupts the normal execution of your program. Common exceptions include division by zero, file not found, and index out of range.","title":"Understanding Exceptions"},{"location":"course/#example-of-an-exception","text":"# Division by zero exception result = 10 / 0 # This will raise a ZeroDivisionError","title":"Example of an Exception:"},{"location":"course/#common-exceptions","text":"ZeroDivisionError : Raised when you divide by zero. IndexError : Raised when you access an invalid index in a list or other sequence. KeyError : Raised when you access a dictionary with a key that does not exist. ValueError : Raised when a function receives an argument of the correct type but inappropriate value. TypeError : Raised when an operation or function is applied to an object of inappropriate type. FileNotFoundError : Raised when an attempt to open a file that does not exist fails.","title":"Common Exceptions:"},{"location":"course/#exception-handling","text":"You can handle exceptions using try and except blocks. This allows you to catch and handle errors gracefully without stopping the execution of your program.","title":"Exception Handling"},{"location":"course/#basic-syntax","text":"try: # Code that might raise an exception pass except ExceptionType: # Code to execute if an exception occurs pass try: result = 10 / 0 except ZeroDivisionError: print(\"Cannot divide by zero!\")","title":"Basic Syntax:"},{"location":"course/#handling-multiple-exceptions","text":"You can handle multiple exceptions by specifying multiple except blocks. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\")","title":"Handling Multiple Exceptions"},{"location":"course/#using-else-and-finally","text":"The else block is executed if no exceptions are raised in the try block. The finally block is executed regardless of whether an exception is raised or not, and is often used for cleanup actions. try: number = int(input(\"Enter a number: \")) result = 10 / number except ZeroDivisionError: print(\"Cannot divide by zero!\") except ValueError: print(\"Invalid input! Please enter a valid number.\") else: print(f\"The result is {result}\") finally: print(\"Execution complete.\")","title":"Using else and finally"},{"location":"course/#raising-exceptions","text":"You can raise exceptions using the raise keyword. This is useful when you want to enforce certain conditions in your code. def check_age(age): if age < 0: raise ValueError(\"Age cannot be negative!\") return age try: age = check_age(-1) except ValueError as e: print(e)","title":"Raising Exceptions"},{"location":"course/#creating-custom-exceptions","text":"You can create custom exceptions by defining a new class that inherits from the built-in Exception class. class CustomError(Exception): pass def test_custom_exception(): raise CustomError(\"This is a custom exception!\") try: test_custom_exception() except CustomError as e: print(e)","title":"Creating Custom Exceptions"},{"location":"course/#practical-applications_2","text":"File Handling with Exception Handling: Exception handling is often used when working with files to handle scenarios where a file might not exist or cannot be opened. try: with open(\"nonexistent_file.txt\", \"r\") as file: content = file.read() except FileNotFoundError: print(\"The file does not exist.\") Input Validation: Exception handling can be used to validate user input and handle invalid inputs gracefully. def get_integer_input(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"Invalid input! Please enter a valid integer.\") age = get_integer_input(\"Enter your age: \") print(f\"Your age is {age}.\")","title":"Practical Applications"},{"location":"course/#practice-time_13","text":"Try the following exercises to get comfortable with exception handling: Basic Exception Handling: Write a program that asks the user for two numbers and divides the first by the second. Handle division by zero and invalid input exceptions. Handling Multiple Exceptions: Write a program that opens a file and reads its contents. Handle file not found and permission denied exceptions. Using else and finally : Write a program that calculates the square root of a number entered by the user. Use else to print the result if no exception occurs and finally to print a completion message. Raising Exceptions: Write a function that checks if a number is within a specified range. Raise a custom exception if the number is out of range and handle this exception in your main program. Creating Custom Exceptions: Create a custom exception called InvalidEmailError and write a function that validates an email address. Raise the custom exception if the email is invalid and handle it in your main program. By mastering exception handling, you'll be able to write more robust and reliable programs that can gracefully handle unexpected errors and conditions. Happy coding!","title":"Practice Time!"},{"location":"links/","text":"Useful Links","title":"Useful Links"},{"location":"links/#useful-links","text":"","title":"Useful Links"}]}